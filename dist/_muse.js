/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ // runtime can't be in strict mode because a global variable is assign and maybe created.
/******/ var __webpack_modules__ = ({

/***/ "./node_modules/render-jsx/dist/es6/common/errors/ref-already-resolved.error.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/common/errors/ref-already-resolved.error.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RefAlreadyResolvedError: () => (/* binding */ RefAlreadyResolvedError)\n/* harmony export */ });\n/*global RefLike*/\nclass RefAlreadyResolvedError extends Error {\n    /*istanbul ignore next*/\n    constructor(ref) {\n        super('Attempting to resolve an already-resolved reference.');\n        this.ref = ref;\n        Object.setPrototypeOf(this, RefAlreadyResolvedError.prototype);\n    }\n}\n//# sourceMappingURL=ref-already-resolved.error.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/common/errors/ref-already-resolved.error.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/common/errors/unresolved-ref.error.js":
/*!********************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/common/errors/unresolved-ref.error.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnresolvedRefError: () => (/* binding */ UnresolvedRefError)\n/* harmony export */ });\n/*global RefLike*/\nclass UnresolvedRefError extends Error {\n    /*istanbul ignore next*/\n    constructor(ref) {\n        super('Referenced value read before it was resolved.');\n        this.ref = ref;\n        Object.setPrototypeOf(this, UnresolvedRefError.prototype);\n    }\n}\n//# sourceMappingURL=unresolved-ref.error.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/common/errors/unresolved-ref.error.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/common/plugins/content-prop.plugin.js":
/*!********************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/common/plugins/content-prop.plugin.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentPropPlugin: () => (/* binding */ ContentPropPlugin)\n/* harmony export */ });\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderer */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/plugin.js\");\n\nclass ContentPropPlugin extends _renderer__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    setProp(node, prop, target) {\n        if (prop === '_content') {\n            this.renderer().setContent(node, target);\n            return true;\n        }\n        return false;\n    }\n    priority() {\n        return _renderer__WEBPACK_IMPORTED_MODULE_0__.Plugin.PriorityFallback;\n    }\n}\n//# sourceMappingURL=content-prop.plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/common/plugins/content-prop.plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/common/plugins/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/common/plugins/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   commonPlugins: () => (/* binding */ commonPlugins)\n/* harmony export */ });\n/* harmony import */ var _content_prop_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./content-prop.plugin */ \"./node_modules/render-jsx/dist/es6/common/plugins/content-prop.plugin.js\");\n/* harmony import */ var _ref_plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ref.plugin */ \"./node_modules/render-jsx/dist/es6/common/plugins/ref.plugin.js\");\n\n\n\n\nfunction commonPlugins() {\n    return [\n        () => new _ref_plugin__WEBPACK_IMPORTED_MODULE_0__.RefPlugin(),\n        () => new _content_prop_plugin__WEBPACK_IMPORTED_MODULE_1__.ContentPropPlugin(),\n    ];\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/common/plugins/index.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/common/plugins/ref.plugin.js":
/*!***********************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/common/plugins/ref.plugin.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RefPlugin: () => (/* binding */ RefPlugin)\n/* harmony export */ });\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderer */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/plugin.js\");\n/* harmony import */ var _ref__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ref */ \"./node_modules/render-jsx/dist/es6/common/ref.js\");\n\n\nclass RefPlugin extends _renderer__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    setProp(node, prop, target) {\n        if (prop === '_ref' && target instanceof _ref__WEBPACK_IMPORTED_MODULE_1__.Ref) {\n            target.resolve(node);\n            return true;\n        }\n        return false;\n    }\n    priority() {\n        return _renderer__WEBPACK_IMPORTED_MODULE_0__.Plugin.PriorityFallback;\n    }\n}\n//# sourceMappingURL=ref.plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/common/plugins/ref.plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/common/ref.js":
/*!********************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/common/ref.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ref: () => (/* binding */ Ref),\n/* harmony export */   ref: () => (/* binding */ ref)\n/* harmony export */ });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors */ \"./node_modules/render-jsx/dist/es6/common/errors/unresolved-ref.error.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"./node_modules/render-jsx/dist/es6/common/errors/ref-already-resolved.error.js\");\n/*global RefLike*/\n\nclass Ref {\n    constructor() {\n        this._resolved = false;\n    }\n    get resolved() {\n        return this.isResolved();\n    }\n    isResolved() {\n        return this._resolved;\n    }\n    get $() {\n        if (!this.isResolved()) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_0__.UnresolvedRefError(this);\n        }\n        return this._$;\n    }\n    resolve(t) {\n        if (this.isResolved()) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.RefAlreadyResolvedError(this);\n        }\n        this._$ = t;\n        this._resolved = true;\n    }\n}\nfunction ref() {\n    return new Ref();\n}\n//# sourceMappingURL=ref.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/common/ref.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/component/plugins/component.plugin.js":
/*!********************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/component/plugins/component.plugin.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ComponentPlugin: () => (/* binding */ ComponentPlugin)\n/* harmony export */ });\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderer */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/plugin.js\");\n/* harmony import */ var _processor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../processor */ \"./node_modules/render-jsx/dist/es6/component/processor.js\");\n\n\nclass ComponentPlugin extends _renderer__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    constructor(...processors) {\n        super();\n        this.processors = processors;\n    }\n    plug(renderer) {\n        super.plug(renderer);\n        this.processors.forEach(p => p.plug(this.renderer()));\n        /*istanbul ignore else*/\n        if ((0,_renderer__WEBPACK_IMPORTED_MODULE_0__.isRendererWithPlugins)(renderer)) {\n            renderer.plugins.forEach(p => {\n                if (p instanceof _processor__WEBPACK_IMPORTED_MODULE_1__.ComponentProcessor) {\n                    this.processors.push(p);\n                }\n            });\n        }\n        this.processors = this.processors.sort((a, b) => a.priority() - b.priority());\n    }\n    create(tag, props, ...children) {\n        const data = { tag, props: props || {}, children };\n        if (this.match(data)) {\n            let provision = {};\n            const post = [];\n            this.processors.forEach(p => p.process(_provision => provision = Object.assign(Object.assign({}, provision), _provision), _post => post.push(_post), data));\n            const $ = this.createComponent(data, provision);\n            post.reverse().forEach(p => p($));\n            return $;\n        }\n        else {\n            return undefined;\n        }\n    }\n}\n//# sourceMappingURL=component.plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/component/plugins/component.plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/component/plugins/func-comp.plugin.js":
/*!********************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/component/plugins/func-comp.plugin.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionalComponentPlugin: () => (/* binding */ FunctionalComponentPlugin)\n/* harmony export */ });\n/* harmony import */ var _component_plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component.plugin */ \"./node_modules/render-jsx/dist/es6/component/plugins/component.plugin.js\");\n\nclass FunctionalComponentPlugin extends _component_plugin__WEBPACK_IMPORTED_MODULE_0__.ComponentPlugin {\n    createComponent(component, provision) {\n        return component.tag.apply(provision, [component.props, this.renderer(), component.children]);\n    }\n    match(component) {\n        return typeof component.tag === 'function';\n    }\n    priority() {\n        return _component_plugin__WEBPACK_IMPORTED_MODULE_0__.ComponentPlugin.PriorityFallback;\n    }\n}\n//# sourceMappingURL=func-comp.plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/component/plugins/func-comp.plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/component/plugins/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/component/plugins/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   componentPlugins: () => (/* binding */ componentPlugins)\n/* harmony export */ });\n/* harmony import */ var _func_comp_plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./func-comp.plugin */ \"./node_modules/render-jsx/dist/es6/component/plugins/func-comp.plugin.js\");\n/* harmony import */ var _live_component_processor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./live-component.processor */ \"./node_modules/render-jsx/dist/es6/component/plugins/live-component.processor.js\");\n\n\n\n\n\nfunction componentPlugins() {\n    return [\n        () => new _func_comp_plugin__WEBPACK_IMPORTED_MODULE_0__.FunctionalComponentPlugin(),\n        () => new _live_component_processor__WEBPACK_IMPORTED_MODULE_1__.LiveComponentProcessor(),\n    ];\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/component/plugins/index.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/component/plugins/live-component.processor.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/component/plugins/live-component.processor.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LiveComponentProcessor: () => (/* binding */ LiveComponentProcessor)\n/* harmony export */ });\n/* harmony import */ var _processor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../processor */ \"./node_modules/render-jsx/dist/es6/component/processor.js\");\n\nclass LiveComponentProcessor extends _processor__WEBPACK_IMPORTED_MODULE_0__.ComponentProcessor {\n    process(provide, post) {\n        const renderer = this.renderer();\n        const hooks = [];\n        provide({\n            onBind: (fn) => hooks.push({ bind: fn }),\n            onClear: (fn) => hooks.push({ clear: fn }),\n        });\n        post(node => {\n            hooks.forEach(hook => renderer.hook(node, hook));\n        });\n    }\n    priority() {\n        return _processor__WEBPACK_IMPORTED_MODULE_0__.ComponentProcessor.PriorityFallback;\n    }\n}\n//# sourceMappingURL=live-component.processor.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/component/plugins/live-component.processor.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/component/processor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/component/processor.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ComponentProcessor: () => (/* binding */ ComponentProcessor)\n/* harmony export */ });\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/plugin.js\");\n\nclass ComponentProcessor extends _renderer__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n}\n//# sourceMappingURL=processor.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/component/processor.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/dom/component/fragment-lcmarker.processor.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/dom/component/fragment-lcmarker.processor.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FragmentLifeCycleMarkerComponentProcessor: () => (/* binding */ FragmentLifeCycleMarkerComponentProcessor)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common */ \"./node_modules/render-jsx/dist/es6/common/ref.js\");\n/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component */ \"./node_modules/render-jsx/dist/es6/component/processor.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util */ \"./node_modules/render-jsx/dist/es6/dom/util/life-cycle.js\");\n\n\n\nclass FragmentLifeCycleMarkerComponentProcessor extends _component__WEBPACK_IMPORTED_MODULE_0__.ComponentProcessor {\n    process(provide, post) {\n        let marker = undefined;\n        provide({\n            setLifeCycleMarker: (node) => marker = node\n        });\n        post(node => {\n            if (node.nodeType === node.DOCUMENT_FRAGMENT_NODE && marker) {\n                if (marker instanceof _common__WEBPACK_IMPORTED_MODULE_1__.Ref) {\n                    (0,_util__WEBPACK_IMPORTED_MODULE_2__.setLifeCycleMarker)(node, marker.$);\n                }\n                else {\n                    (0,_util__WEBPACK_IMPORTED_MODULE_2__.setLifeCycleMarker)(node, marker);\n                }\n            }\n        });\n    }\n    priority() {\n        return _component__WEBPACK_IMPORTED_MODULE_0__.ComponentProcessor.PriorityFallback +\n            (_component__WEBPACK_IMPORTED_MODULE_0__.ComponentProcessor.PriorityMax - _component__WEBPACK_IMPORTED_MODULE_0__.ComponentProcessor.PriorityFallback) / 100;\n    }\n}\n//# sourceMappingURL=fragment-lcmarker.processor.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/dom/component/fragment-lcmarker.processor.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/dom/errors/unrecognized-tag.error.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/dom/errors/unrecognized-tag.error.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnrecognizedTagError: () => (/* binding */ UnrecognizedTagError)\n/* harmony export */ });\nclass UnrecognizedTagError extends Error {\n    /*istanbul ignore next*/\n    constructor(tag) {\n        super(`Given tag is not recognized: ${tag}`);\n    }\n}\n//# sourceMappingURL=unrecognized-tag.error.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/dom/errors/unrecognized-tag.error.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/dom/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/dom/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommonDOMRenderer: () => (/* binding */ CommonDOMRenderer)\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common */ \"./node_modules/render-jsx/dist/es6/common/plugins/index.js\");\n/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component */ \"./node_modules/render-jsx/dist/es6/component/plugins/index.js\");\n/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./component */ \"./node_modules/render-jsx/dist/es6/dom/component/fragment-lcmarker.processor.js\");\n/* harmony import */ var _live_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./live-renderer */ \"./node_modules/render-jsx/dist/es6/dom/live-renderer.js\");\n/* harmony import */ var _plugins__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins */ \"./node_modules/render-jsx/dist/es6/dom/plugins/index.js\");\n\n\n\n\n\n\n\n\n\n\nclass CommonDOMRenderer extends _live_renderer__WEBPACK_IMPORTED_MODULE_0__.LiveDOMRenderer {\n    constructor(dom = window) {\n        super(dom, ...(0,_component__WEBPACK_IMPORTED_MODULE_1__.componentPlugins)(), () => new _component__WEBPACK_IMPORTED_MODULE_2__.FragmentLifeCycleMarkerComponentProcessor(), ...(0,_common__WEBPACK_IMPORTED_MODULE_3__.commonPlugins)(), ...(0,_plugins__WEBPACK_IMPORTED_MODULE_4__.domPlugins)());\n    }\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/dom/index.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/dom/live-renderer.js":
/*!***************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/dom/live-renderer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LiveDOMRenderer: () => (/* binding */ LiveDOMRenderer)\n/* harmony export */ });\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderer */ \"./node_modules/render-jsx/dist/es6/dom/renderer.js\");\n/* harmony import */ var _util_life_cycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/life-cycle */ \"./node_modules/render-jsx/dist/es6/dom/util/life-cycle.js\");\n\n\nclass LiveDOMRenderer extends _renderer__WEBPACK_IMPORTED_MODULE_0__.DOMRenderer {\n    hook(node, hook) {\n        (0,_util_life_cycle__WEBPACK_IMPORTED_MODULE_1__.attachLifeCycleHook)(hook, node);\n    }\n    postRender(target) {\n        if (target instanceof this.dom.DocumentFragment) {\n            return super.postRender(target);\n        }\n        else {\n            return () => {\n                if (this.document.contains(target)) {\n                    (0,_util_life_cycle__WEBPACK_IMPORTED_MODULE_1__.lifeCycleBind)(target);\n                }\n                super.postRender(target)();\n            };\n        }\n    }\n    plug(...plugins) {\n        return super.plug(...plugins);\n    }\n    clone(...plugins) {\n        return new LiveDOMRenderer(this.dom, ...plugins);\n    }\n    remove(node, temporary) {\n        super.remove(node);\n        if (!temporary) {\n            (0,_util_life_cycle__WEBPACK_IMPORTED_MODULE_1__.lifeCycleClear)(node);\n        }\n    }\n}\n//# sourceMappingURL=live-renderer.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/dom/live-renderer.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/dom/plugins/class.plugin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/dom/plugins/class.plugin.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClassPlugin: () => (/* binding */ ClassPlugin)\n/* harmony export */ });\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderer */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/plugin.js\");\n\nfunction isAddClassPlugin(p) {\n    return !!p.addClass && typeof p.addClass === 'function';\n}\nfunction isToggleClassPlugin(p) {\n    return !!p.addClassToggle && typeof p.addClassToggle === 'function';\n}\nclass ClassPlugin extends _renderer__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    plug(renderer) {\n        super.plug(renderer);\n        if ((0,_renderer__WEBPACK_IMPORTED_MODULE_0__.isRendererWithPlugins)(renderer)) {\n            this.addClassPlugins = renderer.plugins.filter(isAddClassPlugin);\n            this.toggleClassPlugins = renderer.plugins.filter(isToggleClassPlugin);\n        }\n    }\n    priority() {\n        return _renderer__WEBPACK_IMPORTED_MODULE_0__.Plugin.PriorityFallback;\n    }\n    setProp(node, prop, target) {\n        if (prop === 'class') {\n            if (Array.isArray(target)) {\n                target.forEach(cl => {\n                    let prev = '';\n                    const sw = (_cl) => {\n                        if (node.classList.contains(prev)) {\n                            node.classList.remove(prev);\n                        }\n                        node.classList.add(prev = _cl);\n                    };\n                    if (this.addClassPlugins &&\n                        this.addClassPlugins.some(p => isAddClassPlugin(p) && p.addClass(node, cl, sw))) {\n                        return;\n                    }\n                    else if (typeof cl === 'string') {\n                        node.classList.add(cl);\n                    }\n                    else {\n                        this.setToggleMap(cl, node);\n                    }\n                });\n                return true;\n            }\n            else if ((target === null || target === void 0 ? void 0 : target.constructor) === Object) {\n                this.setToggleMap(target, node);\n                return true;\n            }\n        }\n        return false;\n    }\n    setToggleMap(map, node) {\n        Object.entries(map).forEach(([cl, clt]) => {\n            if (this.toggleClassPlugins &&\n                this.toggleClassPlugins.some(p => isToggleClassPlugin(p) && p.addClassToggle(node, cl, clt, v => {\n                    if (v) {\n                        node.classList.add(cl);\n                    }\n                    else {\n                        node.classList.remove(cl);\n                    }\n                }))) {\n                return;\n            }\n            else if (!!clt) {\n                node.classList.add(cl);\n            }\n            else {\n                node.classList.remove(cl);\n            }\n        });\n    }\n}\n//# sourceMappingURL=class.plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/dom/plugins/class.plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/dom/plugins/event-handler.plugin.js":
/*!******************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/dom/plugins/event-handler.plugin.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventHandlerPlugin: () => (/* binding */ EventHandlerPlugin)\n/* harmony export */ });\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderer */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/plugin.js\");\n\nclass EventHandlerPlugin extends _renderer__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    priority() {\n        return _renderer__WEBPACK_IMPORTED_MODULE_0__.Plugin.PriorityFallback;\n    }\n    setProp(node, prop, target) {\n        if (prop.startsWith('on') && typeof target === 'function') {\n            const event = prop.substr(2).toLowerCase();\n            node.addEventListener(event, target);\n            return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=event-handler.plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/dom/plugins/event-handler.plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/dom/plugins/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/dom/plugins/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   domPlugins: () => (/* binding */ domPlugins)\n/* harmony export */ });\n/* harmony import */ var _class_plugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./class.plugin */ \"./node_modules/render-jsx/dist/es6/dom/plugins/class.plugin.js\");\n/* harmony import */ var _event_handler_plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-handler.plugin */ \"./node_modules/render-jsx/dist/es6/dom/plugins/event-handler.plugin.js\");\n/* harmony import */ var _input_state_plugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./input-state.plugin */ \"./node_modules/render-jsx/dist/es6/dom/plugins/input-state.plugin.js\");\n/* harmony import */ var _object_value_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./object-value.plugin */ \"./node_modules/render-jsx/dist/es6/dom/plugins/object-value.plugin.js\");\n/* harmony import */ var _style_plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./style.plugin */ \"./node_modules/render-jsx/dist/es6/dom/plugins/style.plugin.js\");\n\n\n\n\n\n\n\n\n\n\nfunction domPlugins() {\n    return [\n        () => new _event_handler_plugin__WEBPACK_IMPORTED_MODULE_0__.EventHandlerPlugin(),\n        () => new _object_value_plugin__WEBPACK_IMPORTED_MODULE_1__.OptionObjectValuePlugin(),\n        () => new _input_state_plugin__WEBPACK_IMPORTED_MODULE_2__.InputStatePlugin(),\n        () => new _class_plugin__WEBPACK_IMPORTED_MODULE_3__.ClassPlugin(),\n        () => new _style_plugin__WEBPACK_IMPORTED_MODULE_4__.StylePlugin(),\n    ];\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/dom/plugins/index.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/dom/plugins/input-state.plugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/dom/plugins/input-state.plugin.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputStatePlugin: () => (/* binding */ InputStatePlugin)\n/* harmony export */ });\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderer */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/plugin.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ \"./node_modules/render-jsx/dist/es6/dom/util/input-value.js\");\n\n\nclass InputStatePlugin extends _renderer__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    priority() {\n        return _renderer__WEBPACK_IMPORTED_MODULE_0__.Plugin.PriorityFallback;\n    }\n    setProp(node, prop, target) {\n        if (prop === '_state'\n            && (node.nodeName === 'INPUT'\n                || node.nodeName === 'TEXTAREA'\n                || node.nodeName === 'SELECT')\n            && typeof target === 'function') {\n            const renderer = this.renderer();\n            renderer.hook(node, {\n                bind() {\n                    if (node.nodeName === 'INPUT' &&\n                        node.type === 'radio' &&\n                        node.name) {\n                        const i = node;\n                        (i.form || renderer.document)\n                            .querySelectorAll(`input[name=\"${i.name}\"]`)\n                            .forEach(input => {\n                            if (input.form === i.form) {\n                                input.addEventListener('input', () => target((0,_util__WEBPACK_IMPORTED_MODULE_1__.getInputValue)(i)));\n                            }\n                        });\n                    }\n                    else {\n                        node.addEventListener('input', () => target((0,_util__WEBPACK_IMPORTED_MODULE_1__.getInputValue)(node)));\n                    }\n                    target((0,_util__WEBPACK_IMPORTED_MODULE_1__.getInputValue)(node));\n                }\n            });\n            return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=input-state.plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/dom/plugins/input-state.plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/dom/plugins/object-value.plugin.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/dom/plugins/object-value.plugin.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OptionObjectValuePlugin: () => (/* binding */ OptionObjectValuePlugin)\n/* harmony export */ });\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderer */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/plugin.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ \"./node_modules/render-jsx/dist/es6/dom/util/input-value.js\");\n\n\nclass OptionObjectValuePlugin extends _renderer__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    priority() {\n        return _renderer__WEBPACK_IMPORTED_MODULE_0__.Plugin.PriorityFallback;\n    }\n    setProp(node, prop, target) {\n        if (prop === '_value' && node.nodeName === 'OPTION') {\n            (0,_util__WEBPACK_IMPORTED_MODULE_1__.setOptionObjectValue)(node, target);\n            return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=object-value.plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/dom/plugins/object-value.plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/dom/plugins/style.plugin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/dom/plugins/style.plugin.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StylePlugin: () => (/* binding */ StylePlugin)\n/* harmony export */ });\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderer */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/plugin.js\");\n\nfunction isSetStylePlugin(p) {\n    return !!p.setStyle && typeof p.setStyle === 'function';\n}\nclass StylePlugin extends _renderer__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    plug(renderer) {\n        super.plug(renderer);\n        if ((0,_renderer__WEBPACK_IMPORTED_MODULE_0__.isRendererWithPlugins)(renderer)) {\n            this.stylePlugins = renderer.plugins.filter(isSetStylePlugin);\n        }\n    }\n    priority() {\n        return _renderer__WEBPACK_IMPORTED_MODULE_0__.Plugin.PriorityFallback;\n    }\n    setProp(node, prop, target) {\n        if (prop === 'style' && (target === null || target === void 0 ? void 0 : target.constructor) === Object) {\n            Object.entries(target).forEach(([style, value]) => {\n                if (this.stylePlugins &&\n                    this.stylePlugins.some(p => isSetStylePlugin(p) &&\n                        p.setStyle(node, style, value, s => this.setStyle(node, style, s)))) {\n                    return;\n                }\n                else {\n                    this.setStyle(node, style, value);\n                }\n            });\n            return true;\n        }\n        return false;\n    }\n    format(key, value) {\n        const split = key.split('.');\n        return {\n            key: split[0],\n            val: value,\n            unit: split[1] || '',\n        };\n    }\n    setStyle(node, style, value) {\n        if (style === 'transform' && typeof value === 'object') {\n            node.style.transform = Object.entries(value)\n                .map(e => this.format(...e))\n                .map(({ key, val, unit }) => `${key}(${val}${unit})`).join(' ');\n        }\n        else if (style === 'transition' && typeof value === 'object') {\n            node.style.transition = Object.entries(value)\n                .map(e => this.format(...e))\n                .map(({ key, val, unit }) => `${key} ${val}${unit}`).join(', ');\n        }\n        else {\n            const { key, val, unit } = this.format(style, `${value}`);\n            node.style[key] = `${val}${unit}`;\n        }\n    }\n}\n//# sourceMappingURL=style.plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/dom/plugins/style.plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/dom/renderer.js":
/*!**********************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/dom/renderer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOMRenderer: () => (/* binding */ DOMRenderer)\n/* harmony export */ });\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer */ \"./node_modules/render-jsx/dist/es6/renderer/renderer.js\");\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/post-render.plugin.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"./node_modules/render-jsx/dist/es6/dom/errors/unrecognized-tag.error.js\");\n\n\nclass DOMRenderer extends _renderer__WEBPACK_IMPORTED_MODULE_0__.Renderer {\n    constructor(dom = window, ...plugins) {\n        super(...(typeof dom === 'function' ? [dom, ...plugins] : plugins));\n        if (!dom || typeof dom === 'function') {\n            this.dom = window;\n        }\n        else {\n            this.dom = dom;\n        }\n    }\n    get document() { return this.dom.document; }\n    fallbackAppend(target, host) {\n        if (target instanceof this.dom.Node) {\n            host.appendChild(target);\n        }\n        else if (Array.isArray(target)) {\n            target.forEach(child => this.append(child, host));\n        }\n        else {\n            host.appendChild(this.document.createTextNode(`${target}`));\n        }\n    }\n    fallbackSetProp(node, prop, target) {\n        if (node instanceof this.dom.HTMLElement) {\n            if (typeof target === 'boolean') {\n                if (target) {\n                    node.setAttribute(prop, '');\n                }\n                else {\n                    node.removeAttribute(prop);\n                }\n            }\n            else {\n                node.setAttribute(prop, `${target}`);\n            }\n        }\n    }\n    fallbackSetContent(node, target) {\n        if (node instanceof this.dom.HTMLElement) {\n            node.innerHTML = `${target}`;\n        }\n        else {\n            node.textContent = `${target}`;\n        }\n    }\n    fallbackFragment() {\n        return this.document.createDocumentFragment();\n    }\n    fallbackLeaf() {\n        return this.document.createTextNode('');\n    }\n    fallbackCreate(tag, props) {\n        if (!(tag instanceof this.dom.Node || typeof tag === 'string')) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.UnrecognizedTagError(tag);\n        }\n        if (tag instanceof this.dom.Node) {\n            return tag;\n        }\n        else if (props && props.xmlns) {\n            return this.document.createElementNS(`${props.xmlns}`, tag);\n        }\n        else {\n            return this.document.createElement(tag);\n        }\n    }\n    renderOn(target, host) {\n        host.appendChild(target);\n    }\n    renderAfter(target, ref) {\n        if (ref.parentNode) {\n            ref.parentNode.insertBefore(target, ref.nextSibling);\n        }\n    }\n    renderBefore(target, ref) {\n        if (ref.parentNode) {\n            ref.parentNode.insertBefore(target, ref);\n        }\n    }\n    postRender(target) {\n        const post = this.plugins.filter(_renderer__WEBPACK_IMPORTED_MODULE_2__.isPostRenderPlugin);\n        if (target instanceof this.dom.DocumentFragment) {\n            const children = Array.from(target.childNodes);\n            return () => children.forEach(child => { this.postRender(child)(); });\n        }\n        else {\n            return () => post.forEach(p => p.postRender(target));\n        }\n    }\n    remove(node) {\n        var _a;\n        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(node);\n    }\n    clone(...plugins) {\n        return new DOMRenderer(this.dom, ...plugins);\n    }\n}\n//# sourceMappingURL=renderer.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/dom/renderer.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/dom/util/input-value.js":
/*!******************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/dom/util/input-value.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getInputValue: () => (/* binding */ getInputValue),\n/* harmony export */   setOptionObjectValue: () => (/* binding */ setOptionObjectValue)\n/* harmony export */ });\n/* unused harmony exports getOptionObjectValue, setInputValue */\nfunction setOptionObjectValue($, value) {\n    $._value = value;\n}\nfunction getOptionObjectValue($) {\n    return $._value;\n}\nfunction getInputValue($) {\n    if ($.nodeName === 'INPUT') {\n        if ($.type === 'number') {\n            return parseFloat($.value);\n        }\n        else if ($.type === 'checkbox' || $.type === 'radio') {\n            return $.checked;\n        }\n        else {\n            return $.value;\n        }\n    }\n    else if ($.nodeName === 'SELECT') {\n        const s = $;\n        const selected = Array.from(s.selectedOptions).map(option => getOptionObjectValue(option)\n            || option.value\n            || option.text);\n        return s.multiple ? selected : selected[0];\n    }\n    else {\n        return $.value;\n    }\n}\nfunction setInputValue($, value) {\n    if ($.nodeName === 'INPUT') {\n        if ($.type === 'checkbox' || $.type === 'radio') {\n            $.checked = !!value;\n        }\n        else {\n            $.value = value;\n        }\n    }\n    else if ($.nodeName === 'SELECT') {\n        const s = $;\n        const selected = Array.isArray(value) ? value : [value];\n        Array.from(s.options).forEach(option => {\n            option.selected = ((getOptionObjectValue(option) && selected.includes(getOptionObjectValue(option)))\n                || (option.value && selected.includes(option.value))\n                || (!option.value && selected.includes(option.text)));\n        });\n    }\n    else {\n        $.value = value;\n    }\n}\n//# sourceMappingURL=input-value.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/dom/util/input-value.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/dom/util/life-cycle.js":
/*!*****************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/dom/util/life-cycle.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   attachLifeCycleHook: () => (/* binding */ attachLifeCycleHook),\n/* harmony export */   lifeCycleBind: () => (/* binding */ lifeCycleBind),\n/* harmony export */   lifeCycleClear: () => (/* binding */ lifeCycleClear),\n/* harmony export */   setLifeCycleMarker: () => (/* binding */ setLifeCycleMarker)\n/* harmony export */ });\n/* unused harmony exports lifeCycleInfo, fragmentLifeCycleInfo, getLifeCycleMarker */\nfunction lifeCycleInfo(node, createIfNonExistent = false) {\n    const _node = node;\n    if (node.nodeType === node.DOCUMENT_FRAGMENT_NODE) {\n        return fragmentLifeCycleInfo(node, createIfNonExistent);\n    }\n    else {\n        if (_node.lifecycle) {\n            return _node.lifecycle;\n        }\n        else if (createIfNonExistent) {\n            _node.lifecycle = { bound: false };\n            return _node.lifecycle;\n        }\n    }\n}\nfunction fragmentLifeCycleInfo(fragment, createIfNonExistent) {\n    var _a;\n    let marker = getLifeCycleMarker(fragment);\n    /*istanbul ignore if*/\n    if (marker) {\n        return lifeCycleInfo(marker, createIfNonExistent);\n    }\n    else if (createIfNonExistent) {\n        marker = (_a = fragment.ownerDocument) === null || _a === void 0 ? void 0 : _a.createTextNode('');\n        setLifeCycleMarker(fragment, marker);\n        return lifeCycleInfo(marker, true);\n    }\n}\nfunction setLifeCycleMarker(fragment, marker) {\n    fragment.lifecycleMarker = marker;\n    if (!fragment.contains(marker)) {\n        fragment.appendChild(marker);\n    }\n}\nfunction getLifeCycleMarker(fragment) {\n    return fragment.lifecycleMarker;\n}\nfunction lifeCycleClear(node) {\n    const lifecycle = lifeCycleInfo(node);\n    if (lifecycle) {\n        /*istanbul ignore next*/\n        if (lifecycle.cleared) {\n            return;\n        }\n        lifecycle.cleared = true;\n        if (lifecycle.clears) {\n            for (let i = 0, clear = lifecycle.clears[i]; i < lifecycle.clears.length; clear = lifecycle.clears[++i]) {\n                clear();\n            }\n            lifecycle.clears = undefined;\n        }\n    }\n    const children = node.childNodes;\n    for (let i = 0, child = children.item(i); i < children.length; child = children.item(++i)) {\n        lifeCycleClear(child);\n    }\n}\nfunction lifeCycleBind(node) {\n    const lifecycle = lifeCycleInfo(node);\n    if (lifecycle) {\n        /*istanbul ignore next*/\n        if (lifecycle.bound) {\n            return;\n        }\n        lifecycle.bound = true;\n        if (lifecycle.binds) {\n            for (let i = 0, bind = lifecycle.binds[i]; i < lifecycle.binds.length; bind = lifecycle.binds[++i]) {\n                bind();\n            }\n        }\n        lifecycle.binds = undefined;\n    }\n    const children = node.childNodes;\n    for (let i = 0, child = children.item(i); i < children.length; child = children.item(++i)) {\n        lifeCycleBind(child);\n    }\n}\nfunction attachLifeCycleHook(hook, node) {\n    const lifecycle = lifeCycleInfo(node, true);\n    if (hook.bind) {\n        (lifecycle.binds || (lifecycle.binds = [])).push(hook.bind);\n    }\n    if (hook.clear) {\n        (lifecycle.clears || (lifecycle.clears = [])).push(hook.clear);\n    }\n}\n//# sourceMappingURL=life-cycle.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/dom/util/life-cycle.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/renderer/plugin/append.plugin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/renderer/plugin/append.plugin.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAppendPlugin: () => (/* binding */ isAppendPlugin)\n/* harmony export */ });\nfunction isAppendPlugin(plugin) {\n    return !!plugin.append && typeof plugin.append === 'function';\n}\n//# sourceMappingURL=append.plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/renderer/plugin/append.plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/renderer/plugin/content.plugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/renderer/plugin/content.plugin.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isContentPlugin: () => (/* binding */ isContentPlugin)\n/* harmony export */ });\nfunction isContentPlugin(plugin) {\n    return !!plugin.setContent && typeof plugin.setContent === 'function';\n}\n//# sourceMappingURL=content.plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/renderer/plugin/content.plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/renderer/plugin/create.plugin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/renderer/plugin/create.plugin.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isCreatePlugin: () => (/* binding */ isCreatePlugin)\n/* harmony export */ });\nfunction isCreatePlugin(plugin) {\n    return !!plugin.create && typeof plugin.create === 'function';\n}\n//# sourceMappingURL=create.plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/renderer/plugin/create.plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/renderer/plugin/fragment.plugin.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/renderer/plugin/fragment.plugin.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isFragmentPlugin: () => (/* binding */ isFragmentPlugin)\n/* harmony export */ });\nfunction isFragmentPlugin(plugin) {\n    return !!plugin.fragment && typeof plugin.fragment === 'function';\n}\n//# sourceMappingURL=fragment.plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/renderer/plugin/fragment.plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/renderer/plugin/leaf.plugin.js":
/*!*************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/renderer/plugin/leaf.plugin.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isLeafPlugin: () => (/* binding */ isLeafPlugin)\n/* harmony export */ });\nfunction isLeafPlugin(plugin) {\n    return !!plugin.leaf && typeof plugin.leaf === 'function';\n}\n//# sourceMappingURL=leaf.plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/renderer/plugin/leaf.plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/renderer/plugin/plugin.js":
/*!********************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/renderer/plugin/plugin.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Plugin: () => (/* binding */ Plugin),\n/* harmony export */   isRendererWithPlugins: () => (/* binding */ isRendererWithPlugins)\n/* harmony export */ });\n/* harmony import */ var _common_ref__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/ref */ \"./node_modules/render-jsx/dist/es6/common/ref.js\");\n\nclass Plugin {\n    constructor() {\n        this._renderer = (0,_common_ref__WEBPACK_IMPORTED_MODULE_0__.ref)();\n    }\n    plug(renderer) {\n        this._renderer.resolve(renderer);\n    }\n    renderer() {\n        return this._renderer.$;\n    }\n}\nPlugin.PriorityMax = 1;\nPlugin.PriorityFallback = 0;\nfunction isRendererWithPlugins(renderer) {\n    return !!renderer.plugins && Array.isArray(renderer.plugins);\n}\n//# sourceMappingURL=plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/renderer/plugin/plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/renderer/plugin/post-create.plugin.js":
/*!********************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/renderer/plugin/post-create.plugin.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPostCreatePlugin: () => (/* binding */ isPostCreatePlugin)\n/* harmony export */ });\nfunction isPostCreatePlugin(plugin) {\n    return !!plugin.postCreate && typeof plugin.postCreate === 'function';\n}\n//# sourceMappingURL=post-create.plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/renderer/plugin/post-create.plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/renderer/plugin/post-render.plugin.js":
/*!********************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/renderer/plugin/post-render.plugin.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPostRenderPlugin: () => (/* binding */ isPostRenderPlugin)\n/* harmony export */ });\nfunction isPostRenderPlugin(plugin) {\n    return !!plugin.postRender && typeof plugin.postRender === 'function';\n}\n//# sourceMappingURL=post-render.plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/renderer/plugin/post-render.plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/renderer/plugin/prop.plugin.js":
/*!*************************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/renderer/plugin/prop.plugin.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPropPlugin: () => (/* binding */ isPropPlugin)\n/* harmony export */ });\nfunction isPropPlugin(plugin) {\n    return !!plugin.setProp && typeof plugin.setProp === 'function';\n}\n//# sourceMappingURL=prop.plugin.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/renderer/plugin/prop.plugin.js?");

/***/ }),

/***/ "./node_modules/render-jsx/dist/es6/renderer/renderer.js":
/*!***************************************************************!*\
  !*** ./node_modules/render-jsx/dist/es6/renderer/renderer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Renderer: () => (/* binding */ Renderer)\n/* harmony export */ });\n/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugin */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/append.plugin.js\");\n/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugin */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/content.plugin.js\");\n/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugin */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/prop.plugin.js\");\n/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugin */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/create.plugin.js\");\n/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugin */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/post-create.plugin.js\");\n/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugin */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/post-render.plugin.js\");\n/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugin */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/leaf.plugin.js\");\n/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plugin */ \"./node_modules/render-jsx/dist/es6/renderer/plugin/fragment.plugin.js\");\n\nclass Renderer {\n    constructor(...plugins) {\n        this._appendPlugins = [];\n        this._createPlugins = [];\n        this._propPlugins = [];\n        this._contentPlugins = [];\n        this._postCreatePlugins = [];\n        this._postRenderPlugins = [];\n        this._factories = plugins;\n    }\n    _buildPlugins() {\n        if (!this._plugins) {\n            this._plugins = this._factories.map(f => f()).sort((a, b) => b.priority() - a.priority());\n            this._plugins.forEach(p => {\n                p.plug(this);\n                if ((0,_plugin__WEBPACK_IMPORTED_MODULE_0__.isAppendPlugin)(p)) {\n                    this._appendPlugins.push(p);\n                }\n                if ((0,_plugin__WEBPACK_IMPORTED_MODULE_1__.isContentPlugin)(p)) {\n                    this._contentPlugins.push(p);\n                }\n                if ((0,_plugin__WEBPACK_IMPORTED_MODULE_2__.isPropPlugin)(p)) {\n                    this._propPlugins.push(p);\n                }\n                if ((0,_plugin__WEBPACK_IMPORTED_MODULE_3__.isCreatePlugin)(p)) {\n                    this._createPlugins.push(p);\n                }\n                if ((0,_plugin__WEBPACK_IMPORTED_MODULE_4__.isPostCreatePlugin)(p)) {\n                    this._postCreatePlugins.push(p);\n                }\n                if ((0,_plugin__WEBPACK_IMPORTED_MODULE_5__.isPostRenderPlugin)(p)) {\n                    this._postRenderPlugins.push(p);\n                }\n                if ((0,_plugin__WEBPACK_IMPORTED_MODULE_6__.isLeafPlugin)(p) && !this._leafPlugin) {\n                    this._leafPlugin = p;\n                }\n                if ((0,_plugin__WEBPACK_IMPORTED_MODULE_7__.isFragmentPlugin)(p) && !this._fragmentPlugin) {\n                    this._fragmentPlugin = p;\n                }\n            });\n        }\n        return this;\n    }\n    get plugins() { return this._buildPlugins() && this._plugins; }\n    get appendPlugins() { return this._buildPlugins() && this._appendPlugins; }\n    get contentPlugins() { return this._buildPlugins() && this._contentPlugins; }\n    get propPlugins() { return this._buildPlugins() && this._propPlugins; }\n    get createPlugins() { return this._buildPlugins() && this._createPlugins; }\n    get postCreatePlugins() { return this._buildPlugins() && this._postCreatePlugins; }\n    get postRenderPlugins() { return this._buildPlugins() && this._postRenderPlugins; }\n    get leafPlugin() { return this._buildPlugins() && this._leafPlugin; }\n    get fragmentPlugin() { return this._buildPlugins() && this._fragmentPlugin; }\n    plug(...plugins) {\n        return this.clone(...this._factories, ...plugins);\n    }\n    append(target, host) {\n        if (!this.appendPlugins.some(p => p.append(target, host))) {\n            this.fallbackAppend(target, host);\n        }\n    }\n    setProp(node, prop, target) {\n        if (!this.propPlugins.some(p => p.setProp(node, prop, target))) {\n            this.fallbackSetProp(node, prop, target);\n        }\n    }\n    setContent(node, target) {\n        if (!this.contentPlugins.some(p => p.setContent(node, target))) {\n            this.fallbackSetContent(node, target);\n        }\n    }\n    get fragment() {\n        const plugin = this.fragmentPlugin;\n        return plugin ? plugin.fragment() : this.fallbackFragment();\n    }\n    leaf() {\n        const plugin = this.leafPlugin;\n        return plugin ? plugin.leaf() : this.fallbackLeaf();\n    }\n    create(tag, props, ...children) {\n        let candidate = undefined;\n        for (const p of this.createPlugins) {\n            candidate = p.create(tag, props, ...children);\n            if (candidate) {\n                break;\n            }\n        }\n        if (!candidate) {\n            candidate = this.fallbackCreate(tag, props);\n            if (props) {\n                Object.entries(props).forEach(([prop, target]) => this.setProp(candidate, prop, target));\n            }\n            children.forEach(child => this.append(child, candidate));\n        }\n        this.postCreatePlugins.forEach(p => p.postCreate(candidate));\n        return candidate;\n    }\n    render(target) {\n        if (typeof target === 'function') {\n            return this.render(target.apply(undefined, [this]));\n        }\n        const _this = this;\n        const post = this.postRender(target);\n        return {\n            after(ref) {\n                _this.renderAfter(target, ref);\n                post();\n            },\n            before(ref) {\n                _this.renderBefore(target, ref);\n                post();\n            },\n            on(host) {\n                _this.renderOn(target, host);\n                post();\n            },\n            target,\n        };\n    }\n    postRender(target) {\n        return () => this.postRenderPlugins.forEach(p => p.postRender(target));\n    }\n}\n//# sourceMappingURL=renderer.js.map\n\n//# sourceURL=webpack://_muse/./node_modules/render-jsx/dist/es6/renderer/renderer.js?");

/***/ }),

/***/ "./node_modules/solid-toast/dist/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/solid-toast/dist/esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Toaster: () => (/* binding */ Toaster),\n/* harmony export */   \"default\": () => (/* binding */ toast)\n/* harmony export */ });\n/* unused harmony exports ActionType, resolveValue, toast */\n/* harmony import */ var solid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! solid-js/web */ \"./node_modules/solid-js/dist/dev.js\");\n/* harmony import */ var solid_js_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! solid-js/store */ \"./node_modules/solid-js/store/dist/dev.js\");\n/* harmony import */ var solid_js_web__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! solid-js/web */ \"./node_modules/solid-js/web/dist/dev.js\");\n\n\n\n\nconst isFunction = valOrFunction => typeof valOrFunction === 'function';\n\nconst resolveValue = (valOrFunction, arg) => isFunction(valOrFunction) ? valOrFunction(arg) : valOrFunction;\n\nlet ActionType;\n\n(function (ActionType) {\n  ActionType[ActionType[\"ADD_TOAST\"] = 0] = \"ADD_TOAST\";\n  ActionType[ActionType[\"UPDATE_TOAST\"] = 1] = \"UPDATE_TOAST\";\n  ActionType[ActionType[\"UPSERT_TOAST\"] = 2] = \"UPSERT_TOAST\";\n  ActionType[ActionType[\"DISMISS_TOAST\"] = 3] = \"DISMISS_TOAST\";\n  ActionType[ActionType[\"REMOVE_TOAST\"] = 4] = \"REMOVE_TOAST\";\n  ActionType[ActionType[\"START_PAUSE\"] = 5] = \"START_PAUSE\";\n  ActionType[ActionType[\"END_PAUSE\"] = 6] = \"END_PAUSE\";\n})(ActionType || (ActionType = {}));\n\nconst [store, setStore] = (0,solid_js_store__WEBPACK_IMPORTED_MODULE_0__.createStore)({\n  toasts: [],\n  pausedAt: undefined\n});\nconst createTimers = () => {\n  const {\n    pausedAt,\n    toasts\n  } = store;\n  if (pausedAt) return;\n  const now = Date.now();\n  const timers = toasts.map(toast => {\n    if (toast.duration === Infinity) return;\n    const durationLeft = (toast.duration || 0) + toast.pauseDuration - (now - toast.createdAt);\n\n    if (durationLeft <= 0) {\n      if (toast.visible) {\n        dispatch({\n          type: ActionType.DISMISS_TOAST,\n          toastId: toast.id\n        });\n      }\n\n      return;\n    }\n\n    return setTimeout(() => {\n      dispatch({\n        type: ActionType.DISMISS_TOAST,\n        toastId: toast.id\n      });\n    }, durationLeft);\n  });\n  return timers;\n};\nconst removalQueue = new Map();\n\nconst scheduleRemoval = (toastId, unmountDelay) => {\n  if (removalQueue.has(toastId)) return;\n  const timeout = setTimeout(() => {\n    removalQueue.delete(toastId);\n    dispatch({\n      type: ActionType.REMOVE_TOAST,\n      toastId\n    });\n  }, unmountDelay);\n  removalQueue.set(toastId, timeout);\n};\n\nconst unscheduleRemoval = toastId => {\n  const timeout = removalQueue.get(toastId);\n  removalQueue.delete(toastId);\n  if (timeout) clearTimeout(timeout);\n};\n\nconst dispatch = action => {\n  switch (action.type) {\n    case ActionType.ADD_TOAST:\n      setStore('toasts', t => {\n        const toasts = t;\n        return [action.toast, ...toasts];\n      });\n      break;\n\n    case ActionType.DISMISS_TOAST:\n      const {\n        toastId\n      } = action;\n      const toasts = store.toasts;\n\n      if (toastId) {\n        const toastToRemove = toasts.find(t => t.id === toastId);\n        if (toastToRemove) scheduleRemoval(toastId, toastToRemove.unmountDelay);\n        setStore('toasts', t => t.id === toastId, (0,solid_js_store__WEBPACK_IMPORTED_MODULE_0__.produce)(t => t.visible = false));\n      } else {\n        toasts.forEach(t => {\n          scheduleRemoval(t.id, t.unmountDelay);\n        });\n        setStore('toasts', t => t.id !== undefined, (0,solid_js_store__WEBPACK_IMPORTED_MODULE_0__.produce)(t => t.visible = false));\n      }\n\n      break;\n\n    case ActionType.REMOVE_TOAST:\n      if (!action.toastId) {\n        setStore('toasts', []);\n        break;\n      }\n\n      setStore('toasts', t => {\n        const toasts = t;\n        return toasts.filter(t => t.id !== action.toastId);\n      });\n      break;\n\n    case ActionType.UPDATE_TOAST:\n      if (action.toast.id) {\n        unscheduleRemoval(action.toast.id);\n      }\n\n      setStore('toasts', t => t.id === action.toast.id, t => {\n        const toast = t;\n        return { ...toast,\n          ...action.toast\n        };\n      });\n      break;\n\n    case ActionType.UPSERT_TOAST:\n      store.toasts.find(t => t.id === action.toast.id) ? dispatch({\n        type: ActionType.UPDATE_TOAST,\n        toast: action.toast\n      }) : dispatch({\n        type: ActionType.ADD_TOAST,\n        toast: action.toast\n      });\n      break;\n\n    case ActionType.START_PAUSE:\n      setStore((0,solid_js_store__WEBPACK_IMPORTED_MODULE_0__.produce)(s => {\n        s.pausedAt = Date.now();\n        s.toasts.forEach(t => {\n          t.paused = true;\n        });\n      }));\n      break;\n\n    case ActionType.END_PAUSE:\n      const pauseInterval = action.time - (store.pausedAt || 0);\n      setStore((0,solid_js_store__WEBPACK_IMPORTED_MODULE_0__.produce)(s => {\n        s.pausedAt = undefined;\n        s.toasts.forEach(t => {\n          t.pauseDuration += pauseInterval;\n          t.paused = false;\n        });\n      }));\n      break;\n  }\n};\n\nconst defaultTimeouts = {\n  blank: 4000,\n  error: 4000,\n  success: 2000,\n  loading: Infinity,\n  custom: 4000\n};\nconst defaultToastOptions = {\n  id: '',\n  icon: '',\n  unmountDelay: 500,\n  duration: 3000,\n  ariaProps: {\n    role: 'status',\n    'aria-live': 'polite'\n  },\n  className: '',\n  style: {},\n  position: 'top-right',\n  iconTheme: {}\n};\nconst defaultToasterOptions = {\n  position: 'top-right',\n  toastOptions: defaultToastOptions,\n  gutter: 8,\n  containerStyle: {},\n  containerClassName: ''\n};\nconst defaultContainerPadding = '16px';\nconst defaultContainerStyle = {\n  position: 'fixed',\n  'z-index': 9999,\n  top: defaultContainerPadding,\n  bottom: defaultContainerPadding,\n  left: defaultContainerPadding,\n  right: defaultContainerPadding,\n  'pointer-events': 'none'\n};\n\nconst generateID = (() => {\n  let count = 0;\n  return () => String(++count);\n})();\nconst mergeContainerOptions = props => {\n  setDefaultOpts(s => ({\n    containerClassName: props.containerClassName ?? s.containerClassName,\n    containerStyle: props.containerStyle ?? s.containerStyle,\n    gutter: props.gutter ?? s.gutter,\n    position: props.position ?? s.position,\n    toastOptions: { ...props.toastOptions\n    }\n  }));\n};\nconst getToastWrapperStyles = (position, offset) => {\n  const top = position.includes('top');\n  const verticalStyle = top ? {\n    top: 0,\n    'margin-top': `${offset}px`\n  } : {\n    bottom: 0,\n    'margin-bottom': `${offset}px`\n  };\n  const horizontalStyle = position.includes('center') ? {\n    'justify-content': 'center'\n  } : position.includes('right') ? {\n    'justify-content': 'flex-end'\n  } : {};\n  return {\n    left: 0,\n    right: 0,\n    display: 'flex',\n    position: 'absolute',\n    transition: `all 230ms cubic-bezier(.21,1.02,.73,1)`,\n    ...verticalStyle,\n    ...horizontalStyle\n  };\n};\nconst updateToastHeight = (ref, toast) => {\n  const boundingRect = ref.getBoundingClientRect();\n\n  if (boundingRect.height !== toast.height) {\n    dispatch({\n      type: ActionType.UPDATE_TOAST,\n      toast: {\n        id: toast.id,\n        height: boundingRect.height\n      }\n    });\n  }\n};\nconst getWrapperYAxisOffset = (toast, position) => {\n  const {\n    toasts\n  } = store;\n  const gutter = defaultOpts().gutter || defaultToasterOptions.gutter || 8;\n  const relevantToasts = toasts.filter(t => (t.position || position) === position && t.height);\n  const toastIndex = relevantToasts.findIndex(t => t.id === toast.id);\n  const toastsBefore = relevantToasts.filter((toast, i) => i < toastIndex && toast.visible).length;\n  const offset = relevantToasts.slice(0, toastsBefore).reduce((acc, t) => acc + gutter + (t.height || 0), 0);\n  return offset;\n};\nconst getToastYDirection = (toast, defaultPos) => {\n  const position = toast.position || defaultPos;\n  const top = position.includes('top');\n  return top ? 1 : -1;\n};\n\nconst toastBarBase = {\n  display: 'flex',\n  'align-items': 'center',\n  color: '#363636',\n  background: 'white',\n  'box-shadow': '0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05)',\n  'max-width': '350px',\n  'pointer-events': 'auto',\n  padding: '8px 10px',\n  'border-radius': '4px',\n  'line-height': '1.3',\n  'will-change': 'transform'\n};\nconst messageContainer = {\n  display: 'flex',\n  'align-items': 'center',\n  flex: '1 1 auto',\n  margin: '4px 10px',\n  'white-space': 'pre-line'\n};\nconst iconContainer = {\n  'flex-shrink': 0,\n  'min-width': '20px',\n  'min-height': '20px',\n  display: 'flex',\n  'align-items': 'center',\n  'justify-content': 'center',\n  'text-align': 'center'\n};\nconst genSVGCubicBezier = keySplines => ({\n  calcMode: 'spline',\n  keyTimes: '0; 1',\n  keySplines: keySplines\n});\n\nconst [defaultOpts, setDefaultOpts] = (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createSignal)(defaultToasterOptions);\nconst createToast = (message, type = 'blank', options) => ({ ...defaultToastOptions,\n  ...defaultOpts().toastOptions,\n  ...options,\n  type,\n  message,\n  pauseDuration: 0,\n  createdAt: Date.now(),\n  visible: true,\n  id: options.id || generateID(),\n  paused: false,\n  style: { ...defaultToastOptions.style,\n    ...defaultOpts().toastOptions?.style,\n    ...options.style\n  },\n  duration: options.duration || defaultOpts().toastOptions?.duration || defaultTimeouts[type],\n  position: options.position || defaultOpts().toastOptions?.position || defaultOpts().position || defaultToastOptions.position\n});\n\nconst createToastCreator = type => (message, options = {}) => {\n  return (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createRoot)(() => {\n    const existingToast = store.toasts.find(t => t.id === options.id);\n    const toast = createToast(message, type, { ...existingToast,\n      duration: undefined,\n      ...options\n    });\n    dispatch({\n      type: ActionType.UPSERT_TOAST,\n      toast\n    });\n    return toast.id;\n  });\n};\n\nconst toast$1 = (message, opts) => createToastCreator('blank')(message, opts);\n\n(0,solid_js__WEBPACK_IMPORTED_MODULE_1__.untrack)(() => toast$1);\ntoast$1.error = createToastCreator('error');\ntoast$1.success = createToastCreator('success');\ntoast$1.loading = createToastCreator('loading');\ntoast$1.custom = createToastCreator('custom');\n\ntoast$1.dismiss = toastId => {\n  dispatch({\n    type: ActionType.DISMISS_TOAST,\n    toastId\n  });\n};\n\ntoast$1.promise = (promise, msgs, opts) => {\n  const id = toast$1.loading(msgs.loading, { ...opts\n  });\n  promise.then(p => {\n    toast$1.success(resolveValue(msgs.success, p), {\n      id,\n      ...opts\n    });\n    return p;\n  }).catch(e => {\n    toast$1.error(resolveValue(msgs.error, e), {\n      id,\n      ...opts\n    });\n  });\n  return promise;\n};\n\ntoast$1.remove = toastId => {\n  dispatch({\n    type: ActionType.REMOVE_TOAST,\n    toastId\n  });\n};\n\nconst _tmpl$$6 = /*#__PURE__*/(0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.template)(`<div><style>.sldt-active{z-index:9999;}.sldt-active>*{pointer-events:auto;}</style></div>`, 4);\nconst Toaster = props => {\n  (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createEffect)(() => {\n    mergeContainerOptions(props);\n  });\n  (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createEffect)(() => {\n    const timers = createTimers();\n    (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.onCleanup)(() => {\n      if (!timers) return;\n      timers.forEach(timer => timer && clearTimeout(timer));\n    });\n  });\n  return (() => {\n    const _el$ = _tmpl$$6.cloneNode(true);\n          _el$.firstChild;\n\n    (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.insert)(_el$, (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createComponent)(solid_js__WEBPACK_IMPORTED_MODULE_1__.For, {\n      get each() {\n        return store.toasts;\n      },\n\n      children: toast => (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createComponent)(ToastContainer, {\n        toast: toast\n      })\n    }), null);\n\n    (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createRenderEffect)(_p$ => {\n      const _v$ = { ...defaultContainerStyle,\n        ...props.containerStyle\n      },\n            _v$2 = props.containerClassName;\n      _p$._v$ = (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.style)(_el$, _v$, _p$._v$);\n      _v$2 !== _p$._v$2 && (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.className)(_el$, _p$._v$2 = _v$2);\n      return _p$;\n    }, {\n      _v$: undefined,\n      _v$2: undefined\n    });\n\n    return _el$;\n  })();\n};\n\nconst _tmpl$$5 = /*#__PURE__*/(0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.template)(`<div></div>`, 2),\n      _tmpl$2$1 = /*#__PURE__*/(0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.template)(`<div><div></div></div>`, 4);\nconst ToastBar = props => {\n  let el;\n  (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createEffect)(() => {\n    if (!el) return;\n    const direction = getToastYDirection(props.toast, props.position);\n\n    if (props.toast.visible) {\n      el.animate([{\n        transform: `translate3d(0,${direction * -200}%,0) scale(.6)`,\n        opacity: 0.5\n      }, {\n        transform: 'translate3d(0,0,0) scale(1)',\n        opacity: 1\n      }], {\n        duration: 350,\n        fill: 'forwards',\n        easing: 'cubic-bezier(.21,1.02,.73,1)'\n      });\n    } else {\n      el.animate([{\n        transform: 'translate3d(0,0,-1px) scale(1)',\n        opacity: 1\n      }, {\n        transform: `translate3d(0,${direction * -150}%,-1px) scale(.4)`,\n        opacity: 0\n      }], {\n        duration: 400,\n        fill: 'forwards',\n        easing: 'cubic-bezier(.06,.71,.55,1)'\n      });\n    }\n  });\n  return (() => {\n    const _el$ = _tmpl$2$1.cloneNode(true),\n          _el$6 = _el$.firstChild;\n\n    const _ref$ = el;\n    typeof _ref$ === \"function\" ? _ref$(_el$) : el = _el$;\n\n    (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.insert)(_el$, (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createComponent)(solid_js__WEBPACK_IMPORTED_MODULE_1__.Switch, {\n      get children() {\n        return [(0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createComponent)(solid_js__WEBPACK_IMPORTED_MODULE_1__.Match, {\n          get when() {\n            return props.toast.icon;\n          },\n\n          get children() {\n            const _el$2 = _tmpl$$5.cloneNode(true);\n\n            (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.insert)(_el$2, () => props.toast.icon);\n\n            (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createRenderEffect)(_$p => (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.style)(_el$2, iconContainer, _$p));\n\n            return _el$2;\n          }\n\n        }), (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createComponent)(solid_js__WEBPACK_IMPORTED_MODULE_1__.Match, {\n          get when() {\n            return props.toast.type === 'loading';\n          },\n\n          get children() {\n            const _el$3 = _tmpl$$5.cloneNode(true);\n\n            (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.insert)(_el$3, (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createComponent)(Loader, (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(() => props.toast.iconTheme)));\n\n            (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createRenderEffect)(_$p => (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.style)(_el$3, iconContainer, _$p));\n\n            return _el$3;\n          }\n\n        }), (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createComponent)(solid_js__WEBPACK_IMPORTED_MODULE_1__.Match, {\n          get when() {\n            return props.toast.type === 'success';\n          },\n\n          get children() {\n            const _el$4 = _tmpl$$5.cloneNode(true);\n\n            (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.insert)(_el$4, (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createComponent)(Success, (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(() => props.toast.iconTheme)));\n\n            (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createRenderEffect)(_$p => (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.style)(_el$4, iconContainer, _$p));\n\n            return _el$4;\n          }\n\n        }), (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createComponent)(solid_js__WEBPACK_IMPORTED_MODULE_1__.Match, {\n          get when() {\n            return props.toast.type === 'error';\n          },\n\n          get children() {\n            const _el$5 = _tmpl$$5.cloneNode(true);\n\n            (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.insert)(_el$5, (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createComponent)(Error, (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(() => props.toast.iconTheme)));\n\n            (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createRenderEffect)(_$p => (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.style)(_el$5, iconContainer, _$p));\n\n            return _el$5;\n          }\n\n        })];\n      }\n\n    }), _el$6);\n\n    (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.spread)(_el$6, () => props.toast.ariaProps, false, true);\n\n    (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.insert)(_el$6, () => resolveValue(props.toast.message, props.toast));\n\n    (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createRenderEffect)(_p$ => {\n      const _v$ = props.toast.className,\n            _v$2 = { ...toastBarBase,\n        ...props.toast.style\n      },\n            _v$3 = messageContainer;\n      _v$ !== _p$._v$ && (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.className)(_el$, _p$._v$ = _v$);\n      _p$._v$2 = (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.style)(_el$, _v$2, _p$._v$2);\n      _p$._v$3 = (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.style)(_el$6, _v$3, _p$._v$3);\n      return _p$;\n    }, {\n      _v$: undefined,\n      _v$2: undefined,\n      _v$3: undefined\n    });\n\n    return _el$;\n  })();\n};\n\nconst _tmpl$$4 = /*#__PURE__*/(0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.template)(`<div></div>`, 2);\nconst ToastContainer = props => {\n  const calculatePosition = () => {\n    const position = props.toast.position || defaultToastOptions.position;\n    const offset = getWrapperYAxisOffset(props.toast, position);\n    const positionStyle = getToastWrapperStyles(position, offset);\n    return positionStyle;\n  };\n\n  const positionStyle = (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createMemo)(() => calculatePosition());\n  let el = undefined;\n  (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.onMount)(() => {\n    if (el) {\n      updateToastHeight(el, props.toast);\n    }\n  });\n  return (() => {\n    const _el$ = _tmpl$$4.cloneNode(true);\n\n    _el$.addEventListener(\"mouseleave\", () => dispatch({\n      type: ActionType.END_PAUSE,\n      time: Date.now()\n    }));\n\n    _el$.addEventListener(\"mouseenter\", () => dispatch({\n      type: ActionType.START_PAUSE,\n      time: Date.now()\n    }));\n\n    const _ref$ = el;\n    typeof _ref$ === \"function\" ? _ref$(_el$) : el = _el$;\n\n    (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.insert)(_el$, (() => {\n      const _c$ = (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createMemo)(() => props.toast.type === 'custom', true);\n\n      return () => _c$() ? resolveValue(props.toast.message, props.toast) : (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createComponent)(ToastBar, {\n        get toast() {\n          return props.toast;\n        },\n\n        get position() {\n          return props.toast.position || defaultToastOptions.position;\n        }\n\n      });\n    })());\n\n    (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createRenderEffect)(_p$ => {\n      const _v$ = positionStyle(),\n            _v$2 = props.toast.visible ? 'sldt-active' : '';\n\n      _p$._v$ = (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.style)(_el$, _v$, _p$._v$);\n      _v$2 !== _p$._v$2 && (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.className)(_el$, _p$._v$2 = _v$2);\n      return _p$;\n    }, {\n      _v$: undefined,\n      _v$2: undefined\n    });\n\n    return _el$;\n  })();\n};\n\nconst _tmpl$$3 = /*#__PURE__*/(0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.template)(`<svg><circle cx=\"16\" cy=\"16\" r=\"0\"><animate attributeName=\"opacity\" values=\"0; 1; 1\"></animate><animate attributeName=\"r\" values=\"0; 17.5; 16\"></animate></circle></svg>`, 8, true),\n      _tmpl$2 = /*#__PURE__*/(0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.template)(`<svg><circle cx=\"16\" cy=\"16\" r=\"12\" opacity=\"0\"><animate attributeName=\"opacity\" values=\"1; 0\"></animate><animate attributeName=\"r\" values=\"12; 26\"></animate></circle></svg>`, 8, true);\nconst MainCircle = props => {\n  const publicProps = {\n    dur: '0.35s',\n    begin: '100ms',\n    fill: 'freeze',\n    calcMode: 'spline',\n    keyTimes: '0; 0.6; 1',\n    keySplines: '0.25 0.71 0.4 0.88; .59 .22 .87 .63'\n  };\n  return (() => {\n    const _el$ = _tmpl$$3.cloneNode(true),\n          _el$2 = _el$.firstChild,\n          _el$3 = _el$2.nextSibling;\n\n    (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.spread)(_el$2, publicProps, true, false);\n\n    (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.spread)(_el$3, publicProps, true, false);\n\n    (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createRenderEffect)(() => (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.setAttribute)(_el$, \"fill\", props.fill));\n\n    return _el$;\n  })();\n};\nconst SecondaryCircle = props => {\n  const publicProps = {\n    dur: '1s',\n    begin: props.begin || '320ms',\n    fill: 'freeze',\n    ...genSVGCubicBezier('0.0 0.0 0.2 1')\n  };\n  return (() => {\n    const _el$4 = _tmpl$2.cloneNode(true),\n          _el$5 = _el$4.firstChild,\n          _el$6 = _el$5.nextSibling;\n\n    (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.spread)(_el$5, publicProps, true, false);\n\n    (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.spread)(_el$6, publicProps, true, false);\n\n    (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createRenderEffect)(() => (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.setAttribute)(_el$4, \"fill\", props.fill));\n\n    return _el$4;\n  })();\n};\n\nconst _tmpl$$2 = /*#__PURE__*/(0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.template)(`<svg viewBox=\"0 0 32 32\" width=\"1.25rem\" height=\"1.25rem\"><path fill=\"none\" stroke-width=\"4\" stroke-dasharray=\"22\" stroke-dashoffset=\"22\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" d=\"M9.8,17.2l3.8,3.6c0.1,0.1,0.3,0.1,0.4,0l9.6-9.7\"><animate attributeName=\"stroke-dashoffset\" values=\"22;0\" dur=\"0.25s\" begin=\"250ms\" fill=\"freeze\"></animate></path></svg>`, 6);\nconst Success = props => {\n  const fill = props.primary || '#34C759';\n  return (() => {\n    const _el$ = _tmpl$$2.cloneNode(true),\n          _el$2 = _el$.firstChild,\n          _el$3 = _el$2.firstChild;\n\n    _el$.style.setProperty(\"overflow\", \"visible\");\n\n    (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.insert)(_el$, (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createComponent)(MainCircle, {\n      fill: fill\n    }), _el$2);\n\n    (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.insert)(_el$, (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createComponent)(SecondaryCircle, {\n      fill: fill,\n      begin: \"350ms\"\n    }), _el$2);\n\n    (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.spread)(_el$3, () => genSVGCubicBezier('0.0, 0.0, 0.58, 1.0'), true, false);\n\n    (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createRenderEffect)(() => (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.setAttribute)(_el$2, \"stroke\", props.secondary || '#FCFCFC'));\n\n    return _el$;\n  })();\n};\n\nconst _tmpl$$1 = /*#__PURE__*/(0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.template)(`<svg viewBox=\"0 0 32 32\" width=\"1.25rem\" height=\"1.25rem\"><path fill=\"none\" stroke-width=\"4\" stroke-dasharray=\"9\" stroke-dashoffset=\"9\" stroke-linecap=\"round\" d=\"M16,7l0,9\"><animate attributeName=\"stroke-dashoffset\" values=\"9;0\" dur=\"0.2s\" begin=\"250ms\" fill=\"freeze\"></animate></path><circle cx=\"16\" cy=\"23\" r=\"2.5\" opacity=\"0\"><animate attributeName=\"opacity\" values=\"0;1\" dur=\"0.25s\" begin=\"350ms\" fill=\"freeze\"></animate></circle></svg>`, 10);\nconst Error = props => {\n  const fill = props.primary || '#FF3B30';\n  return (() => {\n    const _el$ = _tmpl$$1.cloneNode(true),\n          _el$2 = _el$.firstChild,\n          _el$3 = _el$2.firstChild,\n          _el$4 = _el$2.nextSibling,\n          _el$5 = _el$4.firstChild;\n\n    _el$.style.setProperty(\"overflow\", \"visible\");\n\n    (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.insert)(_el$, (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createComponent)(MainCircle, {\n      fill: fill\n    }), _el$2);\n\n    (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.insert)(_el$, (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createComponent)(SecondaryCircle, {\n      fill: fill\n    }), _el$2);\n\n    (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.spread)(_el$3, () => genSVGCubicBezier('0.0, 0.0, 0.58, 1.0'), true, false);\n\n    (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.spread)(_el$5, () => genSVGCubicBezier('0.0, 0.0, 0.58, 1.0'), true, false);\n\n    (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createRenderEffect)(_p$ => {\n      const _v$ = props.secondary || '#FFFFFF',\n            _v$2 = props.secondary || '#FFFFFF';\n\n      _v$ !== _p$._v$ && (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.setAttribute)(_el$2, \"stroke\", _p$._v$ = _v$);\n      _v$2 !== _p$._v$2 && (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.setAttribute)(_el$4, \"fill\", _p$._v$2 = _v$2);\n      return _p$;\n    }, {\n      _v$: undefined,\n      _v$2: undefined\n    });\n\n    return _el$;\n  })();\n};\n\nconst _tmpl$ = /*#__PURE__*/(0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.template)(`<svg viewBox=\"0 0 32 32\" width=\"1.25rem\" height=\"1.25rem\"><path fill=\"none\" stroke-width=\"4\" stroke-miterlimit=\"10\" d=\"M16,6c3,0,5.7,1.3,7.5,3.4c1.5,1.8,2.5,4,2.5,6.6c0,5.5-4.5,10-10,10S6,21.6,6,16S10.5,6,16,6z\"></path><path fill=\"none\" stroke-width=\"4\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" d=\"M16,6c3,0,5.7,1.3,7.5,3.4c0.6,0.7,1.1,1.4,1.5,2.2\"><animateTransform attributeName=\"transform\" type=\"rotate\" from=\"0 16 16\" to=\"360 16 16\" dur=\"0.75s\" repeatCount=\"indefinite\"></animateTransform></path></svg>`, 8);\n\nconst Loader = props => (() => {\n  const _el$ = _tmpl$.cloneNode(true),\n        _el$2 = _el$.firstChild,\n        _el$3 = _el$2.nextSibling;\n\n  _el$.style.setProperty(\"overflow\", \"visible\");\n\n  (0,solid_js__WEBPACK_IMPORTED_MODULE_1__.createRenderEffect)(_p$ => {\n    const _v$ = props.primary || '#E5E7EB',\n          _v$2 = props.secondary || '#4b5563';\n\n    _v$ !== _p$._v$ && (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.setAttribute)(_el$2, \"stroke\", _p$._v$ = _v$);\n    _v$2 !== _p$._v$2 && (0,solid_js_web__WEBPACK_IMPORTED_MODULE_2__.setAttribute)(_el$3, \"stroke\", _p$._v$2 = _v$2);\n    return _p$;\n  }, {\n    _v$: undefined,\n    _v$2: undefined\n  });\n\n  return _el$;\n})();\n\nvar toast = toast$1;\n\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://_muse/./node_modules/solid-toast/dist/esm/index.js?");

/***/ }),

/***/ "./source/about.ts":
/*!*************************!*\
  !*** ./source/about.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   About: () => (/* binding */ About)\n/* harmony export */ });\n/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../package.json */ \"./package.json\");\n/**\n * About\n */\n\nvar About;\n(function (About) {\n    About.version = _package_json__WEBPACK_IMPORTED_MODULE_0__.version;\n    About.libraryName = _package_json__WEBPACK_IMPORTED_MODULE_0__.fullName;\n    About.description = _package_json__WEBPACK_IMPORTED_MODULE_0__.description;\n})(About || (About = {}));\n\n\n//# sourceURL=webpack://_muse/./source/about.ts?");

/***/ }),

/***/ "./source/array.ts":
/*!*************************!*\
  !*** ./source/array.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayFn: () => (/* binding */ ArrayFn)\n/* harmony export */ });\n/**\n * Array\n */\nvar ArrayFn;\n(function (ArrayFn) {\n    /**\n     *\n     * @param param0\n     */\n    function containsAny({ sourceString, arrayOfSubStrings }) {\n        for (const subString of arrayOfSubStrings) {\n            if (sourceString.indexOf(subString) != -1)\n                return true;\n        }\n        return false;\n    }\n    ArrayFn.containsAny = containsAny;\n})(ArrayFn || (ArrayFn = {}));\n\n\n//# sourceURL=webpack://_muse/./source/array.ts?");

/***/ }),

/***/ "./source/check.ts":
/*!*************************!*\
  !*** ./source/check.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Check: () => (/* binding */ Check)\n/* harmony export */ });\n/**\n * Check\n */\nvar Check;\n(function (Check) {\n    /**\n     * Checks if current window is an iframe.\n     * @returns {boolean} True if current window is an iframe, otherwise false.\n     */\n    function isIframe() {\n        const isIframe = (window !== window.parent);\n        return isIframe;\n    }\n    Check.isIframe = isIframe;\n    /**\n     * Checks if 'window' global variable is accessible.\n     * @returns {boolean} True if window is accessible, otherwise false.\n     */\n    function isWindowAccessible() {\n        const objectType = 'object';\n        const isWindowAccessible = (typeof window === objectType) ? true : false;\n        return isWindowAccessible;\n    }\n    Check.isWindowAccessible = isWindowAccessible;\n    /**\n     * Checks if 'unsafeWindow' global variable is accessible.\n     * @returns {boolean} True if unsafeWindow is accessible, otherwise false.\n     */\n    function isUnsafeWindowAccessible() {\n        const objectType = 'object';\n        // @ts-ignore\n        const isUnsafeWindowAccessible = (typeof unsafeWindow === objectType) ? true : false;\n        return isUnsafeWindowAccessible;\n    }\n    Check.isUnsafeWindowAccessible = isUnsafeWindowAccessible;\n})(Check || (Check = {}));\n\n\n//# sourceURL=webpack://_muse/./source/check.ts?");

/***/ }),

/***/ "./source/clone.ts":
/*!*************************!*\
  !*** ./source/clone.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Clone: () => (/* binding */ Clone)\n/* harmony export */ });\n/* harmony import */ var selector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! selector */ \"./source/selector.ts\");\n/**\n * Clone\n */\n\nvar Clone;\n(function (Clone) {\n    /**\n     * Clones an element based on a selector, and optionally appends it to a destination selector.\n     * @param {Object} [o] Element selector object.\n     * @param {string} [o.elementSelector] Source element selector.\n     * @param {string} [o.sourceSelector] Source element selector (alternative).\n     * @param {string} [o.destinationSelector] Destination element selector.\n     * @returns {Node} Cloned node.\n     */\n    function element({ elementSelector = '', sourceSelector = '', destinationSelector = '' }) {\n        try {\n            const elementSelectorInUse = elementSelector.length > 0 ? true : false;\n            const sourceSelectorInUse = sourceSelector.length > 0 ? true : false;\n            if (elementSelectorInUse && sourceSelectorInUse) {\n                const message = `There's two source selectors.`;\n                throw new Error(message);\n            }\n            if (!elementSelectorInUse && !sourceSelectorInUse) {\n                const message = 'No source selectors were provided.';\n                throw new Error(message);\n            }\n            let clonedNode;\n            let destinationNode = undefined;\n            sourceSelector = elementSelector.length > 0 ? elementSelector : sourceSelector;\n            const sourceElement = selector__WEBPACK_IMPORTED_MODULE_0__.Selector.get(sourceSelector);\n            const sourceNode = sourceElement.cloneNode(true);\n            if (destinationSelector.length > 0) {\n                const destinationElement = selector__WEBPACK_IMPORTED_MODULE_0__.Selector.getElement({ selector: destinationSelector });\n                destinationNode = destinationElement.appendChild(sourceNode);\n            }\n            clonedNode = (destinationNode instanceof Node) ? destinationNode : sourceNode;\n            return clonedNode;\n        }\n        catch (error) {\n            const message = 'Failed to clone element.';\n            const cause = { cause: error };\n            throw new Error(message, cause);\n        }\n    }\n    Clone.element = element;\n    /**\n     * Clone an array of elements to a destination\n     * @param {Array<ElementSelectorObject>} arrayOfElementSelectorObject Array of element selctor objects.\n     * @returns {Array<Node>} Array of cloned nodes.\n     */\n    function elementAll(arrayOfElementSelectorObject) {\n        try {\n            const isParameterArrayEmpty = arrayOfElementSelectorObject.length === 0 ? true : false;\n            if (isParameterArrayEmpty) {\n                const message = 'Parameter array is empty.';\n                throw new Error(message);\n            }\n            const clonedNodes = [];\n            for (const elementSelectorObject of arrayOfElementSelectorObject) {\n                const clonedNode = Clone.element(elementSelectorObject);\n                clonedNodes.push(clonedNode);\n            }\n            return clonedNodes;\n        }\n        catch (error) {\n            const message = 'Failed to clone elements in bulk.';\n            const cause = { cause: error };\n            throw new Error(message, cause);\n        }\n    }\n    Clone.elementAll = elementAll;\n})(Clone || (Clone = {}));\n\n\n//# sourceURL=webpack://_muse/./source/clone.ts?");

/***/ }),

/***/ "./source/console.ts":
/*!***************************!*\
  !*** ./source/console.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Console: () => (/* binding */ Console)\n/* harmony export */ });\n/* harmony import */ var about__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! about */ \"./source/about.ts\");\n/**\n * Console\n */\n\nvar Console;\n(function (Console) {\n    let Function;\n    (function (Function) {\n        /**\n         * Console log the result of a function\n         * @param isSuccess\n         * @param error\n         */\n        function result({ errorObject = undefined, useLibraryName = false } = {}) {\n            try {\n                const isSuccess = (typeof errorObject === 'undefined') ? true : false;\n                const status = isSuccess ? '✅' : '❌';\n                const prefix = useLibraryName ? `${about__WEBPACK_IMPORTED_MODULE_0__.About.libraryName}::` : '';\n                const callerFunction = (new Error()).stack?.split('\\n')[2].trim().split(' ')[1].toString();\n                const message = `${prefix}${callerFunction}: ${status}`;\n                window.console.log(message);\n                if (isSuccess === false)\n                    window.console.error(errorObject);\n            }\n            catch (error) {\n                const message = 'Failed to log function result.';\n                const cause = { cause: error };\n                throw new Error(message, cause);\n            }\n        }\n        Function.result = result;\n    })(Function = Console.Function || (Console.Function = {}));\n})(Console || (Console = {}));\n\n\n//# sourceURL=webpack://_muse/./source/console.ts?");

/***/ }),

/***/ "./source/darkmode.ts":
/*!****************************!*\
  !*** ./source/darkmode.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Darkmode: () => (/* binding */ Darkmode)\n/* harmony export */ });\n/* harmony import */ var style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style */ \"./source/style.ts\");\n/**\n * Darkmode\n */\n\nvar Darkmode;\n(function (Darkmode) {\n    /**\n     * Get a prepared CSS string to inject in this context.\n     * @param {Object} [o] Invert colors object, contains style parameters.\n     * @param {number} [o.invert=1] Inversion percentage (from 0 to 1).\n     * @param {string} [o.tags] Tags or selectors to apply inversion to.\n     * @param {string} [o.additionalFilters] Additional filters to add besides invert.\n     * @returns Returns a prepared CSS string.\n     */\n    function getCssString({ invert = 1, tags = 'html, img, video, iframe', additionalFilters = '' } = {}) {\n        const cssString = `\r\n            body { background: white; }\r\n            ${tags} { filter: invert(${invert}) ${additionalFilters}; }\r\n        `;\n        return cssString;\n    }\n    /**\n     * Inverts colors of specific tags or selectors to achieve darkmode.\n     * @param {Object} [o] Invert colors object, contains style parameters.\n     * @param {number} [o.invert=1] Inversion percentage (from 0 to 1).\n     * @param {string} [o.tags='html, img, video, iframe'] Tags or selectors to apply inversion to.\n     * @param {string} [o.additionalfilters=''] Additional filters to add besides invert.\n     * @returns {HTMLStyleElement} Returns an html style element if successful, otherwise an error.\n     */\n    function invertColors({ invert = 1, tags = 'html, img, video, iframe', additionalFilters = '' } = {}) {\n        try {\n            const css = getCssString({ invert, tags, additionalFilters });\n            const styleElement = style__WEBPACK_IMPORTED_MODULE_0__.Style.inject({ text: css });\n            return styleElement;\n        }\n        catch (error) {\n            const message = 'Failed to invert colors.';\n            const cause = { cause: error };\n            throw new Error(message, cause);\n        }\n    }\n    Darkmode.invertColors = invertColors;\n    Darkmode.invert = Darkmode.invertColors;\n    /**\n     * Inverts and hue rotates colors of specific tags or selectors to achieve darkmode.\n     * @param {Object} [o] Invert colors and hue rotate object, contains style parameters.\n     * @param {number} [o.invert=1] Inversion percentage (from 0 to 1).\n     * @param {number} [o.rotation=180] Hue rotation in degrees (from 0 to 360).\n     * @param {string} [o.tags='html, img, video, iframe'] Tags or selectors to apply inversion to.\n     * @param {string} [o.additionalfilters=''] Additional filters to add besides invert.\n     * @returns {HTMLStyleElement | Error} Returns an html style element if successful, otherwise an error.\n     */\n    function invertColorsAndHueRotate({ invert = 1, rotation = 180, tags = 'html, img, video, iframe', additionalFilters = '' } = {}) {\n        try {\n            additionalFilters = `hue-rotate(${rotation}deg) ${additionalFilters}`;\n            const styleElement = Darkmode.invertColors({ invert, tags, additionalFilters });\n            return styleElement;\n        }\n        catch (error) {\n            const message = 'Failed to invert colors and hue rotate.';\n            const cause = { cause: error };\n            throw new Error(message, cause);\n        }\n    }\n    Darkmode.invertColorsAndHueRotate = invertColorsAndHueRotate;\n    Darkmode.invertRotate = Darkmode.invertColorsAndHueRotate;\n    /**\n     * Darkmode presets\n     */\n    let Preset;\n    (function (Preset) {\n        /**\n         * Invert colors 90% and hue rotate 180deg.\n         * @returns {HTMLStyleElement} Returns an html style element if successful, otherwise an error.\n         */\n        function invertAndHueRotate90() {\n            const invert = 0.9;\n            return Darkmode.invertColorsAndHueRotate({ invert });\n        }\n        Preset.invertAndHueRotate90 = invertAndHueRotate90;\n        /**\n         * Invert colors 85% and hue rotate 180deg.\n         * @returns {HTMLStyleElement} Returns an html style element if successful, otherwise an error.\n         */\n        function invertAndHueRotate85() {\n            const invert = 0.85;\n            return Darkmode.invertColorsAndHueRotate({ invert });\n        }\n        Preset.invertAndHueRotate85 = invertAndHueRotate85;\n        /**\n         * Invert colors 85%, hue rotate 180deg, alternative tags and contrast 95%.\n         * @returns {HTMLStyleElement} Returns an html style element if successful, otherwise an error.\n         */\n        function invertAndHueRotateAltTagsAndContrast85() {\n            const invert = 0.85;\n            const tags = 'html, img, video';\n            const additionalFilters = 'contrast(0.95)';\n            return Darkmode.invertColorsAndHueRotate({ invert, tags, additionalFilters });\n        }\n        Preset.invertAndHueRotateAltTagsAndContrast85 = invertAndHueRotateAltTagsAndContrast85;\n    })(Preset = Darkmode.Preset || (Darkmode.Preset = {}));\n    /**\n     * Element\n     */\n    let Element;\n    (function (Element) {\n        /**\n         * Get a prepared CSS string for element darkmode methods.\n         * @param {string} selector Element selector.\n         * @returns {string} Prepared CSS string.\n         */\n        function getCssString({ selector = '', method = 1 }) {\n            let cssString;\n            switch (method) {\n                case 1: // Method 1\n                    cssString = `\r\n                        ${selector}, ${selector} a, ${selector} span { color: #000000 !important; }\r\n                        ${selector} { background: #ffffff !important; }\r\n                        ${selector} { filter: invert(1) hue-rotate(180deg) !important; }\r\n                    `;\n                    break;\n                case 2: // Method 2\n                    cssString = `\r\n                        ${selector}, ${selector} a, ${selector} span { color: #000000 !important; }\r\n                        ${selector} { background: #ffffff !important; }\r\n                    `;\n                    break;\n                case 3: // Method 3\n                    cssString = `\r\n                        ${selector} img { filter: invert(1) hue-rotate(180deg) !important; }\r\n                    `;\n                    break;\n                default:\n                    cssString = '';\n                    break;\n            }\n            return cssString;\n        }\n        /**\n         * Apply darkmode to element or array of elements using a preferred method.\n         * @param {string | Array<string>} selectorOrArrayOfSelectors Element selector or array of element selectors.\n         * @param {number} method Darkmode method number.\n         * @returns {Array<HTMLStyleElement > | HTMLStyleElement } Array of style elements or error, single element or error.\n         */\n        function genericMethod({ selectorOrArrayOfSelectors, method = 1 }) {\n            let text;\n            if (Array.isArray(selectorOrArrayOfSelectors)) {\n                let arrayOfStyleElements = [];\n                for (const selector of selectorOrArrayOfSelectors) {\n                    text = getCssString({ selector, method });\n                    const styleElement = style__WEBPACK_IMPORTED_MODULE_0__.Style.addTextHead({ text });\n                    arrayOfStyleElements.push(styleElement);\n                }\n                return arrayOfStyleElements;\n            }\n            else {\n                const selector = selectorOrArrayOfSelectors;\n                text = getCssString({ selector, method });\n                const styleElement = style__WEBPACK_IMPORTED_MODULE_0__.Style.addTextHead({ text });\n                return styleElement;\n            }\n        }\n        /**\n         * Apply darkmode to element or array of elements using method 1.\n         * @param {string | Array<string>} selectorOrArrayOfSelectors Element selector or array of element selectors.\n         * @returns {Array<HTMLStyleElement > | HTMLStyleElement } Array of style elements or error, single element or error.\n         */\n        function method1({ selectorOrArrayOfSelectors }) {\n            const method = 1;\n            return genericMethod({ selectorOrArrayOfSelectors, method });\n        }\n        Element.method1 = method1;\n        /**\n         * Apply darkmode to element or array of elements using method 2.\n         * @param {string | Array<string>} selectorOrArrayOfSelectors Element selector or array of element selectors.\n         * @returns {Array<HTMLStyleElement> | HTMLStyleElement } Array of style elements or error, single element or error.\n         */\n        function method2({ selectorOrArrayOfSelectors }) {\n            const method = 2;\n            return genericMethod({ selectorOrArrayOfSelectors, method });\n        }\n        Element.method2 = method2;\n        /**\n         * Apply darkmode to element or array of elements using method 3.\n         * @param {string | Array<string>} selectorOrArrayOfSelectors Element selector or array of element selectors.\n         * @returns {Array<HTMLStyleElement > | HTMLStyleElement} Array of style elements or error, single element or error.\n         */\n        function method3(selectorOrArrayOfSelectors) {\n            const method = 3;\n            return genericMethod({ selectorOrArrayOfSelectors, method });\n        }\n        Element.method3 = method3;\n    })(Element = Darkmode.Element || (Darkmode.Element = {}));\n})(Darkmode || (Darkmode = {}));\n\n\n//# sourceURL=webpack://_muse/./source/darkmode.ts?");

/***/ }),

/***/ "./source/event.ts":
/*!*************************!*\
  !*** ./source/event.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Event: () => (/* binding */ Event)\n/* harmony export */ });\n/**\n * Event\n */\nvar Event;\n(function (Event) {\n    /**\n     * Wait for the DOM content to be loaded before executing the callback.\n     * @callback callback Callback function to execute once the DOM content is loaded.\n     */\n    function waitDomLoaded(callback) {\n        const eventName = 'DOMContentLoaded';\n        document.addEventListener(eventName, callback);\n    }\n    Event.waitDomLoaded = waitDomLoaded;\n    Event.domLoaded = Event.waitDomLoaded;\n    /**\n     * Wait for the DOM content to be loaded using a promise. Alternative method.\n     * @returns {Promise<void>} Returns a promise that resolves to nothing.\n     */\n    function waitDomLoadedAlt() {\n        return new Promise(function (resolve) {\n            const eventName = 'DOMContentLoaded';\n            document.addEventListener(eventName, function () { resolve(); });\n        });\n    }\n    Event.waitDomLoadedAlt = waitDomLoadedAlt;\n    Event.waitDomLoadedPromise = Event.waitDomLoadedAlt;\n    Event.domLoadedPromise = Event.waitDomLoadedAlt;\n})(Event || (Event = {}));\n\n\n//# sourceURL=webpack://_muse/./source/event.ts?");

/***/ }),

/***/ "./source/function.ts":
/*!****************************!*\
  !*** ./source/function.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionFn: () => (/* binding */ FunctionFn)\n/* harmony export */ });\n/* harmony import */ var selector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! selector */ \"./source/selector.ts\");\n/**\n * Function\n */\n\nvar FunctionFn;\n(function (FunctionFn) {\n    /**\n     * Wait for a function to exist.\n     * @param {string} functionName Function name\n     * @param {number} interval Checking interval, default is 50ms\n     * @param {number} timeout Timeout in ms, default is 15s\n     * @returns {Promise<Function | Error>} Returns promise that resolves to function if successful, otherwise returns an error.\n     */\n    function wait({ functionName, interval = 50, timeout = 15000 }) {\n        return new Promise(function (resolve) {\n            try {\n                const functionChecker = setInterval(function () {\n                    const functionToCheck = window[functionName];\n                    if (functionToCheck instanceof Function) {\n                        clearTimeout(timeoutChecker);\n                        clearInterval(functionChecker);\n                        resolve();\n                    }\n                }, interval);\n                const timeoutChecker = setTimeout(function () {\n                    clearInterval(functionChecker);\n                    const errorMessage = `Failed to wait for function ${functionName} after ${timeout}ms. Function not found.`;\n                    throw new Error(errorMessage);\n                }, timeout);\n            }\n            catch (error) {\n                const errorMessage = `Failed to wait for function with error: ${error.message}.`;\n                throw new Error(errorMessage);\n            }\n        });\n    }\n    FunctionFn.wait = wait;\n    /**\n     * Wait for a 2nd level function to exist.\n     * @param {string} firstLevel First level name\n     * @param {string} secondLevel Second level function name\n     * @param {number} interval Checking interval\n     * @param {number} timeout Timeout in ms\n     * @returns {Promise<Function | Error>} Returns promise that resolves to function if successful, otherwise returns an error.\n     */\n    function waitFor2ndLevel({ firstLevel, secondLevel, interval = 50, timeout = 15000 }) {\n        return new Promise(function (resolve) {\n            try {\n                const functionChecker = setInterval(function () {\n                    if (typeof window[firstLevel] !== undefined) {\n                        const functionToCheck = window[firstLevel][secondLevel];\n                        if (functionToCheck instanceof Function) {\n                            clearTimeout(timeoutChecker);\n                            clearInterval(functionChecker);\n                            resolve(functionToCheck);\n                        }\n                    }\n                }, interval);\n                const timeoutChecker = setTimeout(function () {\n                    clearInterval(functionChecker);\n                    const errorMessage = `Failed to wait for second level function ${firstLevel}.${secondLevel} after ${timeout}ms. Function not found.`;\n                    throw new Error(errorMessage);\n                }, timeout);\n            }\n            catch (error) {\n                const errorMessage = `Failed to wait for second level function with error: ${error.message}.`;\n                throw new Error(errorMessage);\n            }\n        });\n    }\n    FunctionFn.waitFor2ndLevel = waitFor2ndLevel;\n    FunctionFn.wait2nd = FunctionFn.waitFor2ndLevel;\n    /**\n     *\n     */\n    function getList() {\n        try {\n            let scripts = selector__WEBPACK_IMPORTED_MODULE_0__.Selector.getListOfScripts();\n            let functionRegex = /(((\\w|\\.)+)\\((([^)]*)\\)\\;*))/g;\n            let functionList = [];\n            for (const script of scripts) {\n                const contents = script.innerHTML.toString();\n                const matchesArray = Array.from(contents.matchAll(functionRegex));\n                if (matchesArray.length > 0)\n                    for (const match of matchesArray)\n                        functionList.push(match);\n            }\n            return functionList;\n        }\n        catch (error) {\n            const message = 'Failed to get list of functions.';\n            const cause = { cause: error };\n            throw new Error(message, cause);\n        }\n    }\n    FunctionFn.getList = getList;\n    FunctionFn.getAll = FunctionFn.getList;\n    /**\n     *\n     * @param functionName\n     */\n    function getOriginalParameters({ functionName = '' }) {\n        try {\n            const functionList = FunctionFn.getList();\n            for (const fn of functionList) {\n                const currentScript = fn[2].toString();\n                if (currentScript.includes(functionName)) {\n                    const originalParameters = fn[5].toString().split(',');\n                    return originalParameters;\n                }\n            }\n            const message = 'Function name not found.';\n            throw new Error(message);\n        }\n        catch (error) {\n            const message = 'Failed to get original function parameters from script list.';\n            const cause = { cause: error };\n            throw new Error(message, cause);\n        }\n    }\n    FunctionFn.getOriginalParameters = getOriginalParameters;\n    FunctionFn.getParameters = FunctionFn.getOriginalParameters;\n})(FunctionFn || (FunctionFn = {}));\n\n\n//# sourceURL=webpack://_muse/./source/function.ts?");

/***/ }),

/***/ "./source/html/special.html.ts":
/*!*************************************!*\
  !*** ./source/html/special.html.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buttonGoToTopAndBottomHtml: () => (/* binding */ buttonGoToTopAndBottomHtml)\n/* harmony export */ });\n/**\n * Special (html)\n */\nconst buttonGoToTopAndBottomHtml = `\r\n    <button onclick=\"document.body.scrollTop = 0; document.documentElement.scrollTop = 0;\" class=\"fast-shortcut first-button\" title=\"Go to top\">↑</button>\r\n    <button onclick=\"document.body.scrollTop = document.body.scrollHeight; document.documentElement.scrollTop = document.body.scrollHeight;\" class=\"fast-shortcut second-button\" title=\"Go to bottom\">↓</button>\r\n    `;\n\n\n//# sourceURL=webpack://_muse/./source/html/special.html.ts?");

/***/ }),

/***/ "./source/master.ts":
/*!**************************!*\
  !*** ./source/master.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   About: () => (/* reexport safe */ _about__WEBPACK_IMPORTED_MODULE_12__.About),\n/* harmony export */   ArrayFn: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_11__.ArrayFn),\n/* harmony export */   Check: () => (/* reexport safe */ _check__WEBPACK_IMPORTED_MODULE_10__.Check),\n/* harmony export */   Clone: () => (/* reexport safe */ _clone__WEBPACK_IMPORTED_MODULE_9__.Clone),\n/* harmony export */   Console: () => (/* reexport safe */ _console__WEBPACK_IMPORTED_MODULE_8__.Console),\n/* harmony export */   Darkmode: () => (/* reexport safe */ _darkmode__WEBPACK_IMPORTED_MODULE_7__.Darkmode),\n/* harmony export */   Event: () => (/* reexport safe */ _event__WEBPACK_IMPORTED_MODULE_6__.Event),\n/* harmony export */   FunctionFn: () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_5__.FunctionFn),\n/* harmony export */   ObjectFn: () => (/* reexport safe */ _object__WEBPACK_IMPORTED_MODULE_4__.ObjectFn),\n/* harmony export */   Script: () => (/* reexport safe */ _script__WEBPACK_IMPORTED_MODULE_3__.Script),\n/* harmony export */   Selector: () => (/* reexport safe */ _selector__WEBPACK_IMPORTED_MODULE_2__.Selector),\n/* harmony export */   Special: () => (/* reexport safe */ _special__WEBPACK_IMPORTED_MODULE_1__.Special),\n/* harmony export */   Style: () => (/* reexport safe */ _style__WEBPACK_IMPORTED_MODULE_0__.Style)\n/* harmony export */ });\n/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style */ \"./source/style.ts\");\n/* harmony import */ var _special__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./special */ \"./source/special.tsx\");\n/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selector */ \"./source/selector.ts\");\n/* harmony import */ var _script__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./script */ \"./source/script.ts\");\n/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./object */ \"./source/object.ts\");\n/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./function */ \"./source/function.ts\");\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./event */ \"./source/event.ts\");\n/* harmony import */ var _darkmode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./darkmode */ \"./source/darkmode.ts\");\n/* harmony import */ var _console__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./console */ \"./source/console.ts\");\n/* harmony import */ var _clone__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./clone */ \"./source/clone.ts\");\n/* harmony import */ var _check__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./check */ \"./source/check.ts\");\n/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./array */ \"./source/array.ts\");\n/* harmony import */ var _about__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./about */ \"./source/about.ts\");\n/**\n * Master\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://_muse/./source/master.ts?");

/***/ }),

/***/ "./source/object.ts":
/*!**************************!*\
  !*** ./source/object.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ObjectFn: () => (/* binding */ ObjectFn)\n/* harmony export */ });\n/**\n * Object\n */\nvar ObjectFn;\n(function (ObjectFn) {\n    /**\n     *\n     * @param objectName\n     * @param param1\n     * @returns\n     */\n    function wait({ objectName, interval = 50, timeout = 15000 }) {\n        return new Promise(function (resolve) {\n            try {\n                const objectChecker = setInterval(function () {\n                    const objectToCheck = window[objectName];\n                    if (objectToCheck instanceof Object) {\n                        clearTimeout(timeoutChecker);\n                        clearInterval(objectChecker);\n                        resolve(objectToCheck);\n                    }\n                }, interval);\n                const timeoutChecker = setTimeout(function () {\n                    clearInterval(objectChecker);\n                    const message = 'Timed out waiting for object.';\n                    throw new Error(message);\n                }, timeout);\n            }\n            catch (error) {\n                const message = 'Failed to wait for object.';\n                const cause = { cause: error };\n                throw new Error(message, cause);\n            }\n        });\n    }\n    ObjectFn.wait = wait;\n    /**\n     * Wait for a 2nd level object to exist.\n     * @param {string} firstLevel First level name\n     * @param {string} secondLevel Second level object name\n     * @param {string} callback Callback function\n     * @param {number} interval Checking interval\n     * @param {number} timeout Timeout in ms\n     * @returns {Promise<Object | Error>} Returns a promise that resolves to an object if successful, otherwise returns an error.\n     */\n    function waitFor2ndLevel({ firstLevel, secondLevel, interval = 50, timeout = 15000 }) {\n        return new Promise(function (resolve) {\n            try {\n                const objectChecker = setInterval(function () {\n                    if (typeof window[firstLevel] !== undefined) {\n                        const objectToCheck = window[firstLevel][secondLevel];\n                        if (objectToCheck instanceof Object) {\n                            clearTimeout(timeoutChecker);\n                            clearInterval(objectChecker);\n                            resolve(objectToCheck);\n                        }\n                    }\n                }, interval);\n                const timeoutChecker = setTimeout(function () {\n                    clearInterval(objectChecker);\n                    const message = 'Timed out waiting for second level object.';\n                    throw new Error(message);\n                }, timeout);\n            }\n            catch (error) {\n                const message = 'Failed to wait for second level object.';\n                const cause = { cause: error };\n                throw new Error(message, cause);\n            }\n        });\n    }\n    ObjectFn.waitFor2ndLevel = waitFor2ndLevel;\n    ObjectFn.wait2nd = ObjectFn.waitFor2ndLevel;\n})(ObjectFn || (ObjectFn = {}));\n\n\n//# sourceURL=webpack://_muse/./source/object.ts?");

/***/ }),

/***/ "./source/script.ts":
/*!**************************!*\
  !*** ./source/script.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Script: () => (/* binding */ Script)\n/* harmony export */ });\n/* harmony import */ var selector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! selector */ \"./source/selector.ts\");\n/**\n * Script\n */\n\nvar Script;\n(function (Script) {\n    Script.getList = selector__WEBPACK_IMPORTED_MODULE_0__.Selector.getListOfScripts;\n    /**\n     * Injects a script from a URL or text into a specific DOM location.\n     * @param {Object} o Function arguments object.\n     * @param {string} [o.url] Script URL.\n     * @param {string} [o.text] Script text.\n     * @param {string} [o.location='head'] Injection location ('head' or 'body').\n     * @param {string} [o.wait=false] Wait for script execution.\n     * @returns {Promise<Event | Error> | HTMLScriptElement | Error} If wait is true returns a promise that resolves to an loaded event if successful, otherwise an error. If wait is false returns a script element if successful, otherwise returns an error.\n     */\n    function inject({ url = '', text = '', location = 'head', wait = false } = {}) {\n        try {\n            const script = text;\n            if (url.length === 0 && script.length === 0) {\n                const message = 'Neither url or script was specified.';\n                throw new Error(message);\n            }\n            const validLocations = ['head', 'body'];\n            if (!(validLocations.includes(location))) {\n                const message = `Invalid location, ${location}.`;\n                throw new Error(message);\n            }\n            let scriptElement = document.createElement('script');\n            scriptElement.type = 'text/javascript';\n            if (url !== '') {\n                scriptElement.src = url;\n            }\n            else if (script !== '') {\n                scriptElement.innerHTML = script;\n            }\n            const locationElement = document[location];\n            if (wait) {\n                return new Promise(function (resolve) {\n                    scriptElement.onload = function (event) { resolve(event); };\n                    scriptElement.onerror = function (error) { throw new Error(error); };\n                    scriptElement = locationElement.appendChild(scriptElement);\n                });\n            }\n            else {\n                scriptElement = locationElement.appendChild(scriptElement);\n                return scriptElement;\n            }\n        }\n        catch (error) {\n            const message = `Failed to inject script.`;\n            const cause = { cause: error };\n            throw new Error(message, cause);\n        }\n    }\n    Script.inject = inject;\n    Script.add = Script.inject;\n    /**\n     * Inject scripts sequentially.\n     * @param {Array<InjectParametersObject>} arrayOfInjectParametersObject Array of injection parameters object.\n     * @returns Array containing script elements or events.\n     */\n    function injectArray(arrayOfInjectParametersObject) {\n        let arrayOfElements = [];\n        let promiseChain = Promise.resolve();\n        for (const injectParametersObject of arrayOfInjectParametersObject) {\n            promiseChain = promiseChain.then(function () {\n                return Script.inject(injectParametersObject);\n            }).then(function (scriptElementOrEvent) {\n                arrayOfElements.push(scriptElementOrEvent);\n            });\n        }\n        return promiseChain.then(function () {\n            return arrayOfElements;\n        }).catch(function (error) {\n            const message = 'Failed to inject scripts in bulk.';\n            const cause = { cause: error };\n            throw new Error(message, cause);\n        });\n    }\n    Script.injectArray = injectArray;\n    Script.addArray = Script.injectArray;\n    /**\n *\n * @param param0\n * @returns\n */\n    function injectArrayHeadUrlWait(arrayOfScriptUrls) {\n        let arrayOfInjectParametersObject = [];\n        for (const scriptUrl of arrayOfScriptUrls)\n            arrayOfInjectParametersObject.push({\n                url: scriptUrl,\n                location: 'head',\n                wait: true\n            });\n        return injectArray(arrayOfInjectParametersObject);\n    }\n    Script.injectArrayHeadUrlWait = injectArrayHeadUrlWait;\n    /**\n     * Removes an external script from the DOM based on its partial source attribute match.\n     * @param {string} scriptName Partial filename/src.\n     * @returns {Boolean | Error} Returns true if successful, otherwise returns an error.\n     */\n    function removeExternal(scriptName) {\n        try {\n            const scriptsCollection = selector__WEBPACK_IMPORTED_MODULE_0__.Selector.getListOfScripts();\n            let removed = false;\n            scriptsCollection.forEach(function (script) {\n                const containsScriptName = script.src.toString().includes(scriptName) ? true : false;\n                if (containsScriptName) {\n                    script.parentNode?.removeChild(script);\n                    removed = true;\n                }\n            });\n            return removed;\n        }\n        catch (error) {\n            const message = `Failed to remove script.`;\n            const cause = { cause: error };\n            throw new Error(message, cause);\n        }\n    }\n    Script.removeExternal = removeExternal;\n    Script.deleteExternal = Script.removeExternal;\n    /**\n     * Remove an array of external scripts from the DOM based on partial source attribute match.\n     * @param arrayOfScriptNames Array of script names.\n     * @returns\n     */\n    function removeExternalArray(arrayOfScriptNames) {\n        try {\n            let removalResults = [];\n            for (const scriptName of arrayOfScriptNames) {\n                const removed = Script.removeExternal(scriptName);\n                removalResults.push({ scriptName, removed });\n            }\n            return removalResults;\n        }\n        catch (error) {\n            const message = 'Failed to bulk remove scripts.';\n            const cause = { cause: error };\n            throw new Error(message, cause);\n        }\n    }\n    Script.removeExternalArray = removeExternalArray;\n    Script.deleteExternalArray = Script.removeExternalArray;\n})(Script || (Script = {}));\n\n\n//# sourceURL=webpack://_muse/./source/script.ts?");

/***/ }),

/***/ "./source/selector.ts":
/*!****************************!*\
  !*** ./source/selector.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Selector: () => (/* binding */ Selector)\n/* harmony export */ });\n/**\n * Selector\n */\nvar Selector;\n(function (Selector) {\n    /**\n     * Selects the first DOM element that matches the selector.\n     * @param {string | object} selectorParameters Element selector string or a selector parameters object.\n     * @param {string} [selectorParameters.selector] Element selector.\n     * @param {string} [selectorParameters.wait] Switch to wait for selector to exist.\n     * @returns {Element | Error} The first Element within the document that matches the specified selector, or Error if no matches are found or there was another error.\n     */\n    function getElement({ selector = '', wait = false }) {\n        try {\n            let element;\n            if (selector.length === 0) {\n                const message = 'Selector parameter is empty.';\n                throw new Error(message);\n            }\n            if (wait)\n                return Selector.waitForElement({ selector });\n            element = document.querySelector(selector);\n            return element;\n        }\n        catch (error) {\n            const message = 'Failed to get element from selector.';\n            const cause = { cause: error };\n            throw new Error(message, cause);\n        }\n    }\n    Selector.getElement = getElement;\n    Selector.get = Selector.getElement;\n    /**\n     * Wait for element to exist.\n     * @param {string} selector Element selector.\n     * @param {number} [timeout=15000] Timeout in milliseconds (default is 15 seconds (15000)).\n     * @returns {Promise<Element>} Promise that resolves to element if found, or rejects with an error if the timeout is reached.\n     */\n    function waitForElement({ selector = '', timeout = 15000 }) {\n        return new Promise(function (resolve, reject) {\n            const element = Selector.getElement({ selector });\n            if (element instanceof Element)\n                resolve(element);\n            const observer = new MutationObserver(function () {\n                const element = Selector.getElement({ selector });\n                if (element instanceof Element) {\n                    observer.disconnect();\n                    clearTimeout(timeoutChecker);\n                    resolve(element);\n                }\n            });\n            const options = {\n                childList: true,\n                subtree: true\n            };\n            const target = document.body;\n            observer.observe(target, options);\n            const timeoutChecker = setTimeout(function () {\n                observer.disconnect();\n                const message = `Timed out waiting for element.`;\n                reject(message);\n            }, timeout);\n        });\n    }\n    Selector.waitForElement = waitForElement;\n    /**\n     * Gets an array of elements.\n     */\n    function getArrayOfElements(arrayOfSelectorParameters) {\n        let arrayOfElements = [];\n        let promiseChain = Promise.resolve();\n        for (const selectorParameters of arrayOfSelectorParameters) {\n            promiseChain = promiseChain.then(function () {\n                return Selector.get(selectorParameters);\n            }).then(function (element) {\n                arrayOfElements.push(element);\n            });\n        }\n        return promiseChain.then(function () {\n            return arrayOfElements;\n        }).catch(function (error) {\n            const message = `Failed to get array of elements.`;\n            const cause = { cause: error };\n            throw new Error(message, cause);\n        });\n    }\n    Selector.getArrayOfElements = getArrayOfElements;\n    Selector.getArray = Selector.getArrayOfElements;\n    /**\n     * Selects all DOM elements that matches the selector.\n     * @param\n     * @returns {}\n     */\n    function getList({ selector }) {\n        try {\n            const elementCollection = document.querySelectorAll(selector);\n            return elementCollection;\n        }\n        catch (error) {\n            const message = 'Failed to get element collection from selector.';\n            const cause = { cause: error };\n            throw new Error(message, cause);\n        }\n    }\n    Selector.getList = getList;\n    Selector.list = Selector.getList;\n    /**\n     * Selects all 'script' elements in the DOM.\n     * @returns\n     */\n    function getListOfScripts() {\n        const selector = 'script';\n        return Selector.getList({ selector });\n    }\n    Selector.getListOfScripts = getListOfScripts;\n    Selector.allScripts = Selector.getListOfScripts;\n    /**\n     * Selects all 'style' elements in the DOM.\n     * @returns\n     */\n    function getListOfStyles() {\n        const selector = 'style';\n        return Selector.getList({ selector });\n    }\n    Selector.getListOfStyles = getListOfStyles;\n    Selector.allStyles = Selector.getListOfStyles;\n})(Selector || (Selector = {}));\n\n\n//# sourceURL=webpack://_muse/./source/selector.ts?");

/***/ }),

/***/ "./source/special.tsx":
/*!****************************!*\
  !*** ./source/special.tsx ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Special: () => (/* binding */ Special)\n/* harmony export */ });\n/* harmony import */ var html_special_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! html/special.html */ \"./source/html/special.html.ts\");\n/* harmony import */ var styles_special_styles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! styles/special.styles */ \"./source/styles/special.styles.ts\");\n/* harmony import */ var style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! style */ \"./source/style.ts\");\n/* harmony import */ var solid_toast__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! solid-toast */ \"./node_modules/solid-toast/dist/esm/index.js\");\n/* harmony import */ var render_jsx_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! render-jsx/dom */ \"./node_modules/render-jsx/dist/es6/dom/index.js\");\n/**\n * Special\n */\n/** @jsx renderer.create */\n\n\n\n\n\nvar Special;\n(function (Special) {\n    /**\n     * Special elements\n     */\n    let Element;\n    (function (Element) {\n        /**\n         *\n         */\n        let Toast;\n        (function (Toast) {\n            /**\n             *\n             */\n            function init({ position = 'bottom-left', gutter = 8 }) {\n                const renderer = new render_jsx_dom__WEBPACK_IMPORTED_MODULE_3__.CommonDOMRenderer();\n                return renderer.render(renderer.create(\"div\", null,\n                    renderer.create(solid_toast__WEBPACK_IMPORTED_MODULE_4__.Toaster, { position: position, gutter: gutter }))).on(document.body);\n            }\n            Toast.init = init;\n            /**\n             *\n             * @param toastId\n             * @returns\n             */\n            function dismiss(toastId) {\n                return solid_toast__WEBPACK_IMPORTED_MODULE_4__[\"default\"].dismiss(toastId);\n            }\n            Toast.dismiss = dismiss;\n            /**\n             *\n             * @param param0\n             */\n            function message({ message = '', toastOptions, type = 'default', promise, promiseMessages = {\n                loading: '',\n                success: '',\n                error: ''\n            } }) {\n                switch (type) {\n                    case 'loading':\n                        return solid_toast__WEBPACK_IMPORTED_MODULE_4__[\"default\"].loading(message, toastOptions);\n                    case 'success':\n                        return solid_toast__WEBPACK_IMPORTED_MODULE_4__[\"default\"].success(message, toastOptions);\n                    case 'error':\n                        return solid_toast__WEBPACK_IMPORTED_MODULE_4__[\"default\"].error(message, toastOptions);\n                    case 'promise':\n                        return solid_toast__WEBPACK_IMPORTED_MODULE_4__[\"default\"].promise(promise, promiseMessages, toastOptions);\n                    default:\n                        return (0,solid_toast__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(message, toastOptions);\n                }\n            }\n            Toast.message = message;\n        })(Toast = Element.Toast || (Element.Toast = {}));\n        /**\n         * Add a button to right bottom corner to got to the top and bottom of the page.\n         * @returns Returns a div element of the injected button, otherwise an error.\n         */\n        function addButtonGoToTopAndBottom() {\n            try {\n                const div = document.createElement('div');\n                const text = styles_special_styles__WEBPACK_IMPORTED_MODULE_1__.buttonGoToTopAndBottomStyle;\n                div.innerHTML = html_special_html__WEBPACK_IMPORTED_MODULE_0__.buttonGoToTopAndBottomHtml;\n                style__WEBPACK_IMPORTED_MODULE_2__.Style.injectTextHead({ text });\n                const injectedDiv = document.body.appendChild(div);\n                return injectedDiv;\n            }\n            catch (error) {\n                const message = `Failed to add go to top and go to bottom buttons.`;\n                const cause = { cause: error };\n                throw new Error(message, cause);\n            }\n        }\n        Element.addButtonGoToTopAndBottom = addButtonGoToTopAndBottom;\n        Element.addTopBottom = Element.addButtonGoToTopAndBottom;\n    })(Element = Special.Element || (Special.Element = {}));\n})(Special || (Special = {}));\n\n\n//# sourceURL=webpack://_muse/./source/special.tsx?");

/***/ }),

/***/ "./source/style.ts":
/*!*************************!*\
  !*** ./source/style.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Style: () => (/* binding */ Style)\n/* harmony export */ });\n/* harmony import */ var selector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! selector */ \"./source/selector.ts\");\n/**\n * Style\n */\n\nvar Style;\n(function (Style) {\n    Style.getList = selector__WEBPACK_IMPORTED_MODULE_0__.Selector.getListOfStyles;\n    /**\n     * Inject stylesheet from URL or text into a specific DOM location.\n     * @param {Object} o Function arguments object.\n     * @param {string} [o.url] Style URL.\n     * @param {string} [o.text] Style text (alternative to URL).\n     * @param {string} [o.location='head'] Injection location ('head' or 'body').\n     * @returns {HTMLStyleElement | HTMLLinkElement | Error} Returns style or link element if successful, otherwise returns an error.\n     */\n    function inject({ url = '', text = '', location = 'head', wait = false }) {\n        try {\n            const style = text;\n            if (url.length === 0 && style.length === 0) {\n                const message = 'Neither url or style was specified.';\n                throw new Error(message);\n            }\n            const validLocations = ['head', 'body'];\n            if (!(validLocations.includes(location))) {\n                const message = `Invalid location, ${location}.`;\n                throw new Error(message);\n            }\n            let linkElement = undefined;\n            let styleElement = undefined;\n            if (url.length > 0) {\n                linkElement = document.createElement('link');\n                linkElement.rel = 'stylesheet';\n                linkElement.type = 'text/css';\n                linkElement.href = url;\n            }\n            else if (style.length > 0) {\n                styleElement = document.createElement('style');\n                styleElement.innerHTML = style;\n            }\n            let stylesheetElement = (styleElement instanceof HTMLStyleElement) ?\n                styleElement :\n                linkElement;\n            const locationElement = document[location];\n            if (wait) {\n                return new Promise(function (resolve) {\n                    stylesheetElement.onload = function (event) { resolve(event); };\n                    stylesheetElement.onerror = function (error) { throw new Error(error); };\n                    stylesheetElement = locationElement.appendChild(stylesheetElement);\n                });\n            }\n            else {\n                stylesheetElement = locationElement.appendChild(stylesheetElement);\n                return stylesheetElement;\n            }\n        }\n        catch (error) {\n            const message = `Failed to inject style.`;\n            const cause = { cause: error };\n            throw new Error(message, cause);\n        }\n    }\n    Style.inject = inject;\n    Style.add = Style.inject;\n    /**\n     * Inject styles sequentially.\n     * @param {Array<InjectParametersObject>} arrayOfInjectParametersObject Array of injection parameters object.\n     * @returns Array containing style, link elements or events.\n     */\n    function injectArray(arrayOfInjectParametersObject) {\n        let arrayOfElements = [];\n        let promiseChain = Promise.resolve();\n        for (const injectParametersObject of arrayOfInjectParametersObject) {\n            promiseChain = promiseChain.then(function () {\n                return Style.inject(injectParametersObject);\n            }).then(function (stylesheetElementOrEvent) {\n                arrayOfElements.push(stylesheetElementOrEvent);\n            });\n        }\n        return promiseChain.then(function () {\n            return arrayOfElements;\n        }).catch(function (error) {\n            const message = 'Failed to inject array of styles.';\n            const cause = { cause: error };\n            throw new Error(message, cause);\n        });\n    }\n    Style.injectArray = injectArray;\n    /**\n     *\n     * @param param0\n     * @returns\n     */\n    function injectArrayHeadUrl(arrayOfStyleUrls) {\n        let arrayOfInjectParametersObject = [];\n        for (const styleUrl of arrayOfStyleUrls)\n            arrayOfInjectParametersObject.push({\n                url: styleUrl,\n                location: 'head'\n            });\n        return injectArray(arrayOfInjectParametersObject);\n    }\n    Style.injectArrayHeadUrl = injectArrayHeadUrl;\n    /**\n     * Inject stylesheet text on head.\n     * @param {string} text Style text.\n     * @returns {HTMLStyleElement} Style element if successful.\n     */\n    function injectTextHead({ text = '' }) {\n        return Style.inject({ text });\n    }\n    Style.injectTextHead = injectTextHead;\n    Style.addTextHead = Style.injectTextHead;\n    /**\n     * Removes an external script from the DOM based on its partial source attribute match.\n     * @param {string} scriptName Partial filename/src.\n     * @returns {Boolean | Error} True on success or error.\n     */\n    function removeExternal({ scriptName = '' }) {\n        try {\n            const scripts = selector__WEBPACK_IMPORTED_MODULE_0__.Selector.getListOfScripts();\n            for (const script of scripts) {\n                const containsScriptName = script.src.toString().includes(scriptName) ? true : false;\n                if (containsScriptName)\n                    script.parentNode?.removeChild(script);\n            }\n            return true;\n        }\n        catch (error) {\n            const message = `Failed to remove script.`;\n            const cause = { cause: error };\n            throw new Error(message, cause);\n        }\n    }\n    Style.removeExternal = removeExternal;\n    Style.deleteExternal = Style.removeExternal;\n    /**\n     * Element\n     */\n    let Element;\n    (function (Element) {\n        /**\n         * Get a prepared CSS string to inject in this context.\n         * @param selector Element selector.\n         * @param css Selector properties.\n         * @returns Returns a prepared CSS string.\n         */\n        function getCssString({ selector = '', method = '', inline = false }) {\n            let cssString;\n            let properties;\n            switch (method) {\n                case 'displayNone':\n                    properties = 'display: none !important;';\n                    break;\n                case 'opacityZero':\n                    properties = 'opacity: 0 !important;';\n                    break;\n                case 'visibilityHidden':\n                    properties = 'visibility: hidden !important;';\n                    break;\n                default:\n                    properties = '';\n                    break;\n            }\n            cssString = inline ? properties : `${selector} { ${properties} }`;\n            return cssString;\n        }\n        /**\n         * Apply inline style to element.\n         * @param selector\n         * @param wait\n         */\n        function inline({ selector = '', css = '', wait = false }) {\n            try {\n                const attribute = 'style';\n                if (wait) {\n                    return new Promise(function (resolve) {\n                        selector__WEBPACK_IMPORTED_MODULE_0__.Selector.getElement({ selector, wait }).then(function (element) {\n                            element.setAttribute(attribute, css);\n                            resolve(element);\n                        });\n                    });\n                }\n                else {\n                    const element = selector__WEBPACK_IMPORTED_MODULE_0__.Selector.getElement({ selector });\n                    element.setAttribute(attribute, css);\n                    return element;\n                }\n            }\n            catch (error) {\n                const message = 'Failed to apply inline style.';\n                const cause = { cause: error };\n                throw new Error(message, cause);\n            }\n        }\n        Element.inline = inline;\n        /**\n         *\n         * @param selectorOrArrayOfSelectors\n         * @param {string} method\n         * @param {boolean} inline\n         * @returns\n         */\n        function genericMethod({ selectorOrArrayOfSelectors, method = '', inline = false, wait = false }) {\n            if (Array.isArray(selectorOrArrayOfSelectors)) { // Array\n                let arrayOfElements = [];\n                if (inline) { // Array, inline\n                    if (wait) { // Array, inline, wait \n                        let promiseChain = Promise.resolve();\n                        for (const selector of selectorOrArrayOfSelectors) {\n                            const css = getCssString({ selector, method, inline });\n                            promiseChain = promiseChain.then(function () {\n                                return Style.Element.inline({ selector, css, wait });\n                            }).then(function (scriptElementOrEvent) {\n                                arrayOfElements.push(scriptElementOrEvent);\n                            });\n                        }\n                        return promiseChain.then(function () {\n                            return arrayOfElements;\n                        }).catch(function (error) {\n                            const message = 'Failed to wait and apply inline darkmode to array of selectors.';\n                            const cause = { cause: error };\n                            throw new Error(message, cause);\n                        });\n                    }\n                    else { // Array, inline, nowait\n                        try {\n                            for (const selector of selectorOrArrayOfSelectors) {\n                                const css = getCssString({ selector, method, inline });\n                                const element = Style.Element.inline({ selector, css });\n                                arrayOfElements.push(element);\n                            }\n                            return arrayOfElements;\n                        }\n                        catch (error) {\n                            const message = 'Failed to apply inline darkmode to array of selectors.';\n                            const cause = { cause: error };\n                            throw new Error(message, cause);\n                        }\n                    }\n                }\n                else { // Array, global\n                    if (wait) { // Array, global, wait\n                        let promiseChain = Promise.resolve();\n                        for (const selector of selectorOrArrayOfSelectors) {\n                            const text = getCssString({ selector, method });\n                            promiseChain = promiseChain.then(function () {\n                                return Style.inject({ text, wait });\n                            }).then(function (scriptElementOrEvent) {\n                                arrayOfElements.push(scriptElementOrEvent);\n                            });\n                        }\n                        return promiseChain.then(function () {\n                            return arrayOfElements;\n                        }).catch(function (error) {\n                            const message = 'Failed to wait and apply darkmode to array of selectors.';\n                            const cause = { cause: error };\n                            throw new Error(message, cause);\n                        });\n                    }\n                    else { // Array, global, nowait\n                        try {\n                            for (const selector of selectorOrArrayOfSelectors) {\n                                const text = getCssString({ selector, method });\n                                const element = Style.inject({ text });\n                                arrayOfElements.push(element);\n                            }\n                            return arrayOfElements;\n                        }\n                        catch (error) {\n                            const message = 'Failed to apply darkmode to array of selectors.';\n                            const cause = { cause: error };\n                            throw new Error(message, cause);\n                        }\n                    }\n                }\n            }\n            else { // Single\n                const selector = selectorOrArrayOfSelectors;\n                if (inline) { // Single, inline\n                    if (wait) { // Single, inline, wait\n                        return new Promise(function (resolve) {\n                            const css = getCssString({ selector, method, inline });\n                            Style.Element.inline({ selector, css, wait }).then(function (element) {\n                                resolve(element);\n                            }).catch(function (error) {\n                                const message = 'Failed to wait and apply inline darkmode to selector.';\n                                const cause = { cause: error };\n                                throw new Error(message, cause);\n                            });\n                        });\n                    }\n                    else { // Single, inline, nowait\n                        try {\n                            const css = getCssString({ selector, method, inline });\n                            const element = Style.Element.inline({ selector, css });\n                            return element;\n                        }\n                        catch (error) {\n                            const message = 'Failed to apply inline darkmode to selector.';\n                            const cause = { cause: error };\n                            throw new Error(message, cause);\n                        }\n                    }\n                }\n                else { // Single, global\n                    if (wait) { // Single, global, wait\n                        return new Promise(function (resolve) {\n                            const text = getCssString({ selector, method });\n                            Style.inject({ text, wait }).then(function (event) {\n                                resolve(event);\n                            }).catch(function (error) {\n                                const message = 'Failed to wait and apply darkmode to selector.';\n                                const cause = { cause: error };\n                                throw new Error(message, cause);\n                            });\n                        });\n                    }\n                    else { // Single, global, nowait\n                        try {\n                            const text = getCssString({ selector, method });\n                            const element = Style.inject({ text });\n                            return element;\n                        }\n                        catch (error) {\n                            const message = 'Failed to apply darkmode to selector.';\n                            const cause = { cause: error };\n                            throw new Error(message, cause);\n                        }\n                    }\n                }\n            }\n        }\n        /**\n         * Add 'display: none !important;' property to an element or array of elements.\n         * @param selectorOrArrayOfSelectors Element selector or array of selectors.\n         * @returns Returns html style element if successful, otherwise an error.\n         */\n        function displayNone({ selectorOrArrayOfSelectors, inline = false, wait = false }) {\n            const method = 'displayNone';\n            return genericMethod({ selectorOrArrayOfSelectors, method, inline, wait });\n        }\n        Element.displayNone = displayNone;\n        /**\n         * Add 'opacity: 0 !important;' property to an element or array of elements.\n         * @param selectorOrArrayOfSelectors Element selector or array of selectors.\n         * @returns Returns html style element if successful, otherwise an error.\n         */\n        function opacityZero({ selectorOrArrayOfSelectors, inline = false, wait = false }) {\n            const method = 'opacityZero';\n            return genericMethod({ selectorOrArrayOfSelectors, method, inline, wait });\n        }\n        Element.opacityZero = opacityZero;\n        /**\n         * Add 'visibility: hidden !important;' property to an element or array of elements.\n         * @param selectorOrArrayOfSelectors Element selector or array of selectors.\n         * @returns Returns html style element if successful, otherwise an error.\n         */\n        function visibilityHidden({ selectorOrArrayOfSelectors, inline = false, wait = false }) {\n            const method = 'visibilityHidden';\n            return genericMethod({ selectorOrArrayOfSelectors, method, inline, wait });\n        }\n        Element.visibilityHidden = visibilityHidden;\n    })(Element = Style.Element || (Style.Element = {}));\n})(Style || (Style = {}));\n\n\n//# sourceURL=webpack://_muse/./source/style.ts?");

/***/ }),

/***/ "./source/styles/special.styles.ts":
/*!*****************************************!*\
  !*** ./source/styles/special.styles.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buttonGoToTopAndBottomStyle: () => (/* binding */ buttonGoToTopAndBottomStyle)\n/* harmony export */ });\nconst buttonGoToTopAndBottomStyle = `\r\n.fast-shortcut {\r\n    width: 40px;\r\n    height: 40px;\r\n    display: block;\r\n    position: fixed;\r\n    bottom: 20px;\r\n    z-index: 99;\r\n    font-size: 25px;\r\n    outline: none;\r\n    background-color: #FFFFFF;\r\n    color: #000000;\r\n    cursor: pointer;\r\n    padding: 2px;\r\n}\r\n\r\n.fast-shortcut.first-button {\r\n    right: 30px;\r\n}\r\n\r\n.fast-shortcut.second-button {\r\n    right: 75px;\r\n}\r\n`;\n\n\n//# sourceURL=webpack://_muse/./source/styles/special.styles.ts?");

/***/ }),

/***/ "./node_modules/solid-js/dist/dev.js":
/*!*******************************************!*\
  !*** ./node_modules/solid-js/dist/dev.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $DEVCOMP: () => (/* binding */ $DEVCOMP),\n/* harmony export */   $PROXY: () => (/* binding */ $PROXY),\n/* harmony export */   $TRACK: () => (/* binding */ $TRACK),\n/* harmony export */   DEV: () => (/* binding */ DEV),\n/* harmony export */   For: () => (/* binding */ For),\n/* harmony export */   Match: () => (/* binding */ Match),\n/* harmony export */   Switch: () => (/* binding */ Switch),\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   createComponent: () => (/* binding */ createComponent),\n/* harmony export */   createEffect: () => (/* binding */ createEffect),\n/* harmony export */   createMemo: () => (/* binding */ createMemo),\n/* harmony export */   createRenderEffect: () => (/* binding */ createRenderEffect),\n/* harmony export */   createRoot: () => (/* binding */ createRoot),\n/* harmony export */   createSignal: () => (/* binding */ createSignal),\n/* harmony export */   enableHydration: () => (/* binding */ enableHydration),\n/* harmony export */   getListener: () => (/* binding */ getListener),\n/* harmony export */   getOwner: () => (/* binding */ getOwner),\n/* harmony export */   mergeProps: () => (/* binding */ mergeProps),\n/* harmony export */   onCleanup: () => (/* binding */ onCleanup),\n/* harmony export */   onMount: () => (/* binding */ onMount),\n/* harmony export */   runWithOwner: () => (/* binding */ runWithOwner),\n/* harmony export */   sharedConfig: () => (/* binding */ sharedConfig),\n/* harmony export */   splitProps: () => (/* binding */ splitProps),\n/* harmony export */   untrack: () => (/* binding */ untrack)\n/* harmony export */ });\n/* unused harmony exports ErrorBoundary, Index, Show, Suspense, SuspenseList, cancelCallback, catchError, children, createComputed, createContext, createDeferred, createReaction, createResource, createSelector, createUniqueId, enableExternalSource, enableScheduling, equalFn, from, indexArray, lazy, mapArray, observable, on, onError, requestCallback, resetErrorBoundaries, startTransition, useContext, useTransition */\nlet taskIdCounter = 1,\n  isCallbackScheduled = false,\n  isPerformingWork = false,\n  taskQueue = [],\n  currentTask = null,\n  shouldYieldToHost = null,\n  yieldInterval = 5,\n  deadline = 0,\n  maxYieldInterval = 300,\n  scheduleCallback = null,\n  scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n    port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = (n + m) >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;\n      else if (cmp < 0) n = k - 1;\n      else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n    timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {\n  context: undefined,\n  registry: undefined\n};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return {\n    ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst $TRACK = Symbol(\"solid-track\");\nconst $DEVCOMP = Symbol(\"solid-dev-component\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst NO_INIT = {};\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet ExternalSourceConfig = null;\nlet Listener = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nconst DevHooks = {\n  afterUpdate: null,\n  afterCreateOwner: null,\n  afterCreateSignal: null\n};\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n    owner = Owner,\n    unowned = fn.length === 0,\n    current = detachedOwner === undefined ? owner : detachedOwner,\n    root = unowned\n      ? {\n          owned: null,\n          cleanups: null,\n          context: null,\n          owner: null\n        }\n      : {\n          owned: null,\n          cleanups: null,\n          context: current ? current.context : null,\n          owner: current\n        },\n    updateFn = unowned\n      ? () =>\n          fn(() => {\n            throw new Error(\"Dispose method must be an explicit argument to createRoot function\");\n          })\n      : () => fn(() => untrack(() => cleanNode(root)));\n  DevHooks.afterCreateOwner && DevHooks.afterCreateOwner(root);\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    comparator: options.equals || undefined\n  };\n  {\n    if (options.name) s.name = options.name;\n    if (DevHooks.afterCreateSignal) DevHooks.afterCreateSignal(s);\n    if (!options.internal) registerGraph(s);\n  }\n  const setter = value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.tValue);\n      else value = value(s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE, options);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);\n  else updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE, options);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);\n  else updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE, options),\n    s = SuspenseContext && useContext(SuspenseContext);\n  if (s) c.suspense = s;\n  if (!options || !options.render) c.user = true;\n  Effects ? Effects.push(c) : updateComputation(c);\n}\nfunction createReaction(onInvalidate, options) {\n  let fn;\n  const c = createComputation(\n      () => {\n        fn ? fn() : untrack(onInvalidate);\n        fn = undefined;\n      },\n      undefined,\n      false,\n      0,\n      options\n    ),\n    s = SuspenseContext && useContext(SuspenseContext);\n  if (s) c.suspense = s;\n  c.user = true;\n  return tracking => {\n    fn = tracking;\n    updateComputation(c);\n  };\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0, options);\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction isPromise(v) {\n  return v && typeof v === \"object\" && \"then\" in v;\n}\nfunction createResource(pSource, pFetcher, pOptions) {\n  let source;\n  let fetcher;\n  let options;\n  if ((arguments.length === 2 && typeof pFetcher === \"object\") || arguments.length === 1) {\n    source = true;\n    fetcher = pSource;\n    options = pFetcher || {};\n  } else {\n    source = pSource;\n    fetcher = pFetcher;\n    options = pOptions || {};\n  }\n  let pr = null,\n    initP = NO_INIT,\n    id = null,\n    loadedUnderTransition = false,\n    scheduled = false,\n    resolved = \"initialValue\" in options,\n    dynamic = typeof source === \"function\" && createMemo(source);\n  const contexts = new Set(),\n    [value, setValue] = (options.storage || createSignal)(options.initialValue),\n    [error, setError] = createSignal(undefined),\n    [track, trigger] = createSignal(undefined, {\n      equals: false\n    }),\n    [state, setState] = createSignal(resolved ? \"ready\" : \"unresolved\");\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    let v;\n    if (options.ssrLoadFrom === \"initial\") initP = options.initialValue;\n    else if (sharedConfig.load && (v = sharedConfig.load(id))) initP = v;\n  }\n  function loadEnd(p, v, error, key) {\n    if (pr === p) {\n      pr = null;\n      key !== undefined && (resolved = true);\n      if ((p === initP || v === initP) && options.onHydrated)\n        queueMicrotask(() =>\n          options.onHydrated(key, {\n            value: v\n          })\n        );\n      initP = NO_INIT;\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          completeLoad(v, error);\n        }, false);\n      } else completeLoad(v, error);\n    }\n    return v;\n  }\n  function completeLoad(v, err) {\n    runUpdates(() => {\n      if (err === undefined) setValue(() => v);\n      setState(err !== undefined ? \"errored\" : resolved ? \"ready\" : \"unresolved\");\n      setError(err);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    }, false);\n  }\n  function read() {\n    const c = SuspenseContext && useContext(SuspenseContext),\n      v = value(),\n      err = error();\n    if (err !== undefined && !pr) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition && loadedUnderTransition) Transition.promises.add(pr);\n          else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching !== false && scheduled) return;\n    scheduled = false;\n    const lookup = dynamic ? dynamic() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p =\n      initP !== NO_INIT\n        ? initP\n        : untrack(() =>\n            fetcher(lookup, {\n              value: value(),\n              refetching\n            })\n          );\n    if (!isPromise(p)) {\n      loadEnd(pr, p, undefined, lookup);\n      return p;\n    }\n    pr = p;\n    if (\"value\" in p) {\n      if (p.status === \"success\") loadEnd(pr, p.value, undefined, lookup);\n      else loadEnd(pr, undefined, castError(p.value), lookup);\n      return p;\n    }\n    scheduled = true;\n    queueMicrotask(() => (scheduled = false));\n    runUpdates(() => {\n      setState(resolved ? \"refreshing\" : \"pending\");\n      trigger();\n    }, false);\n    return p.then(\n      v => loadEnd(p, v, undefined, lookup),\n      e => loadEnd(p, undefined, castError(e), lookup)\n    );\n  }\n  Object.defineProperties(read, {\n    state: {\n      get: () => state()\n    },\n    error: {\n      get: () => error()\n    },\n    loading: {\n      get() {\n        const s = state();\n        return s === \"pending\" || s === \"refreshing\";\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        const err = error();\n        if (err && !pr) throw err;\n        return value();\n      }\n    }\n  });\n  if (dynamic) createComputed(() => load(false));\n  else load(false);\n  return [\n    read,\n    {\n      refetch: load,\n      mutate: setValue\n    }\n  ];\n}\nfunction createDeferred(source, options) {\n  let t,\n    timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(\n    () => {\n      if (!t || !t.fn)\n        t = requestCallback(\n          () => setDeferred(() => node.value),\n          timeout !== undefined\n            ? {\n                timeout\n              }\n            : undefined\n        );\n      return source();\n    },\n    undefined,\n    true\n  );\n  const [deferred, setDeferred] = createSignal(\n    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value,\n    options\n  );\n  updateComputation(node);\n  setDeferred(() =>\n    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value\n  );\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(\n    p => {\n      const v = source();\n      for (const [key, val] of subs.entries())\n        if (fn(key, v) !== fn(key, p)) {\n          for (const c of val.values()) {\n            c.state = STALE;\n            if (c.pure) Updates.push(c);\n            else Effects.push(c);\n          }\n        }\n      return v;\n    },\n    undefined,\n    true,\n    STALE,\n    options\n  );\n  updateComputation(node);\n  return key => {\n    const listener = Listener;\n    if (listener) {\n      let l;\n      if ((l = subs.get(key))) l.add(listener);\n      else subs.set(key, (l = new Set([listener])));\n      onCleanup(() => {\n        l.delete(listener);\n        !l.size && subs.delete(key);\n      });\n    }\n    return fn(\n      key,\n      Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value\n    );\n  };\n}\nfunction batch(fn) {\n  return runUpdates(fn, false);\n}\nfunction untrack(fn) {\n  if (!ExternalSourceConfig && Listener === null) return fn();\n  const listener = Listener;\n  Listener = null;\n  try {\n    if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);\n    return fn();\n  } finally {\n    Listener = listener;\n  }\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return prevValue;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null)\n    console.warn(\"cleanups created outside a `createRoot` or `render` will never be run\");\n  else if (Owner.cleanups === null) Owner.cleanups = [fn];\n  else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction catchError(fn, handler) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  Owner = createComputation(undefined, undefined, true);\n  Owner.context = {\n    ...Owner.context,\n    [ERROR]: [handler]\n  };\n  if (Transition && Transition.running) Transition.sources.add(Owner);\n  try {\n    return fn();\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Owner = Owner.owner;\n  }\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  const prevListener = Listener;\n  Owner = o;\n  Listener = null;\n  try {\n    return runUpdates(fn, true);\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Owner = prev;\n    Listener = prevListener;\n  }\n}\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\nfunction startTransition(fn) {\n  if (Transition && Transition.running) {\n    fn();\n    return Transition.done;\n  }\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n    if (Scheduler || SuspenseContext) {\n      t =\n        Transition ||\n        (Transition = {\n          sources: new Set(),\n          effects: [],\n          promises: new Set(),\n          disposed: new Set(),\n          queue: new Set(),\n          running: true\n        });\n      t.done || (t.done = new Promise(res => (t.resolve = res)));\n      t.running = true;\n    }\n    runUpdates(fn, false);\n    Listener = Owner = null;\n    return t ? t.done : undefined;\n  });\n}\nconst [transPending, setTransPending] = /*@__PURE__*/ createSignal(false);\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction devComponent(Comp, props) {\n  const c = createComputation(\n    () =>\n      untrack(() => {\n        Object.assign(Comp, {\n          [$DEVCOMP]: true\n        });\n        return Comp(props);\n      }),\n    undefined,\n    true,\n    0\n  );\n  c.props = props;\n  c.observers = null;\n  c.observerSlots = null;\n  c.name = Comp.name;\n  c.component = Comp;\n  updateComputation(c);\n  return c.tValue !== undefined ? c.tValue : c.value;\n}\nfunction registerGraph(value) {\n  if (!Owner) return;\n  if (Owner.sourceMap) Owner.sourceMap.push(value);\n  else Owner.sourceMap = [value];\n  value.graph = Owner;\n}\nfunction createContext(defaultValue, options) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id, options),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  return Owner && Owner.context && Owner.context[context.id] !== undefined\n    ? Owner.context[context.id]\n    : context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  const memo = createMemo(() => resolveChildren(children()), undefined, {\n    name: \"children\"\n  });\n  memo.toArray = () => {\n    const c = memo();\n    return Array.isArray(c) ? c : c != null ? [c] : [];\n  };\n  return memo;\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext());\n}\nfunction enableExternalSource(factory, untrack = fn => fn()) {\n  if (ExternalSourceConfig) {\n    const { factory: oldFactory, untrack: oldUntrack } = ExternalSourceConfig;\n    ExternalSourceConfig = {\n      factory: (fn, trigger) => {\n        const oldSource = oldFactory(fn, trigger);\n        const source = factory(x => oldSource.track(x), trigger);\n        return {\n          track: x => source.track(x),\n          dispose() {\n            source.dispose();\n            oldSource.dispose();\n          }\n        };\n      },\n      untrack: fn => oldUntrack(() => untrack(fn))\n    };\n  } else {\n    ExternalSourceConfig = {\n      factory,\n      untrack\n    };\n  }\n}\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n  if (this.sources && (runningTransition ? this.tState : this.state)) {\n    if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);\n    else {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(this), false);\n      Updates = updates;\n    }\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  let current =\n    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;\n  if (!node.comparator || !node.comparator(current, value)) {\n    if (Transition) {\n      const TransitionRunning = Transition.running;\n      if (TransitionRunning || (!isComp && Transition.sources.has(node))) {\n        Transition.sources.add(node);\n        node.tValue = value;\n      }\n      if (!TransitionRunning) node.value = value;\n    } else node.value = value;\n    if (node.observers && node.observers.length) {\n      runUpdates(() => {\n        for (let i = 0; i < node.observers.length; i += 1) {\n          const o = node.observers[i];\n          const TransitionRunning = Transition && Transition.running;\n          if (TransitionRunning && Transition.disposed.has(o)) continue;\n          if (TransitionRunning ? !o.tState : !o.state) {\n            if (o.pure) Updates.push(o);\n            else Effects.push(o);\n            if (o.observers) markDownstream(o);\n          }\n          if (!TransitionRunning) o.state = STALE;\n          else o.tState = STALE;\n        }\n        if (Updates.length > 10e5) {\n          Updates = [];\n          if (true) throw new Error(\"Potential Infinite Loop Detected.\");\n          throw new Error();\n        }\n      }, false);\n    }\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const time = ExecCount;\n  runComputation(\n    node,\n    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value,\n    time\n  );\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        Listener = Owner = node;\n        runComputation(node, node.tValue, time);\n        Listener = Owner = null;\n      }, false);\n    });\n  }\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  const owner = Owner,\n    listener = Listener;\n  Listener = Owner = node;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    if (node.pure) {\n      if (Transition && Transition.running) {\n        node.tState = STALE;\n        node.tOwned && node.tOwned.forEach(cleanNode);\n        node.tOwned = undefined;\n      } else {\n        node.state = STALE;\n        node.owned && node.owned.forEach(cleanNode);\n        node.owned = null;\n      }\n    }\n    node.updatedAt = time + 1;\n    return handleError(err);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.updatedAt != null && \"observers\" in node) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: Owner ? Owner.context : null,\n    pure\n  };\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n  if (Owner === null)\n    console.warn(\"computations created outside a `createRoot` or `render` will never be disposed\");\n  else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];\n      else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];\n      else Owner.owned.push(c);\n    }\n  }\n  if (options && options.name) c.name = options.name;\n  if (ExternalSourceConfig && c.fn) {\n    const [track, trigger] = createSignal(undefined, {\n      equals: false\n    });\n    const ordinary = ExternalSourceConfig.factory(c.fn, trigger);\n    onCleanup(() => ordinary.dispose());\n    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());\n    const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);\n    c.fn = x => {\n      track();\n      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);\n    };\n  }\n  DevHooks.afterCreateOwner && DevHooks.afterCreateOwner(c);\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if ((runningTransition ? node.tState : node.state) === 0) return;\n  if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (runningTransition ? node.tState : node.state) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (runningTransition) {\n      let top = node,\n        prev = ancestors[i + 1];\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n    if ((runningTransition ? node.tState : node.state) === STALE) {\n      updateComputation(node);\n    } else if ((runningTransition ? node.tState : node.state) === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(node, ancestors[0]), false);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;\n  else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!wait) Effects = null;\n    Updates = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);\n    else runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let res;\n  if (Transition) {\n    if (!Transition.promises.size && !Transition.queue.size) {\n      const sources = Transition.sources;\n      const disposed = Transition.disposed;\n      Effects.push.apply(Effects, Transition.effects);\n      res = Transition.resolve;\n      for (const e of Effects) {\n        \"tState\" in e && (e.state = e.tState);\n        delete e.tState;\n      }\n      Transition = null;\n      runUpdates(() => {\n        for (const d of disposed) cleanNode(d);\n        for (const v of sources) {\n          v.value = v.tValue;\n          if (v.owned) {\n            for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n          }\n          if (v.tOwned) v.owned = v.tOwned;\n          delete v.tValue;\n          delete v.tOwned;\n          v.tState = 0;\n        }\n        setTransPending(false);\n      }, false);\n    } else if (Transition.running) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n  }\n  const e = Effects;\n  Effects = null;\n  if (e.length) runUpdates(() => runEffects(e), false);\n  else DevHooks.afterUpdate && DevHooks.afterUpdate();\n  if (res) res();\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\nfunction runUserEffects(queue) {\n  let i,\n    userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);\n    else queue[userLength++] = e;\n  }\n  if (sharedConfig.context) {\n    if (sharedConfig.count) {\n      sharedConfig.effects || (sharedConfig.effects = []);\n      sharedConfig.effects.push(...queue.slice(0, userLength));\n      return;\n    } else if (sharedConfig.effects) {\n      queue = [...sharedConfig.effects, ...queue];\n      userLength += sharedConfig.effects.length;\n      delete sharedConfig.effects;\n    }\n    setHydrateContext();\n  }\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n}\nfunction lookUpstream(node, ignore) {\n  const runningTransition = Transition && Transition.running;\n  if (runningTransition) node.tState = 0;\n  else node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      const state = runningTransition ? source.tState : source.state;\n      if (state === STALE) {\n        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount))\n          runTop(source);\n      } else if (state === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (runningTransition ? !o.tState : !o.state) {\n      if (runningTransition) o.tState = PENDING;\n      else o.state = PENDING;\n      if (o.pure) Updates.push(o);\n      else Effects.push(o);\n      o.observers && markDownstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n        index = node.sourceSlots.pop(),\n        obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n          s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);\n      delete node.tOwned;\n    }\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  if (Transition && Transition.running) node.tState = 0;\n  else node.state = 0;\n  delete node.sourceMap;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction castError(err) {\n  if (err instanceof Error) return err;\n  return new Error(typeof err === \"string\" ? err : \"Unknown error\", {\n    cause: err\n  });\n}\nfunction runErrors(err, fns, owner) {\n  try {\n    for (const f of fns) f(err);\n  } catch (e) {\n    handleError(e, (owner && owner.owner) || null);\n  }\n}\nfunction handleError(err, owner = Owner) {\n  const fns = ERROR && owner && owner.context && owner.context[ERROR];\n  const error = castError(err);\n  if (!fns) throw error;\n  if (Effects)\n    Effects.push({\n      fn() {\n        runErrors(error, fns, owner);\n      },\n      state: STALE\n    });\n  else runErrors(error, fns, owner);\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id, options) {\n  return function provider(props) {\n    let res;\n    createRenderEffect(\n      () =>\n        (res = untrack(() => {\n          Owner.context = {\n            ...Owner.context,\n            [id]: props.value\n          };\n          return children(() => props.children);\n        })),\n      undefined,\n      options\n    );\n    return res;\n  };\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null)\n    console.warn(\"error handlers created outside a `createRoot` or `render` will never be run\");\n  else if (Owner.context === null || !Owner.context[ERROR]) {\n    Owner.context = {\n      ...Owner.context,\n      [ERROR]: [fn]\n    };\n    mutateContext(Owner, ERROR, [fn]);\n  } else Owner.context[ERROR].push(fn);\n}\nfunction mutateContext(o, key, value) {\n  if (o.owned) {\n    for (let i = 0; i < o.owned.length; i++) {\n      if (o.owned[i].context === o.context) mutateContext(o.owned[i], key, value);\n      if (!o.owned[i].context) {\n        o.owned[i].context = o.context;\n        mutateContext(o.owned[i], key, value);\n      } else if (!o.owned[i].context[key]) {\n        o.owned[i].context[key] = value;\n        mutateContext(o.owned[i], key, value);\n      }\n    }\n  }\n}\n\nfunction observable(input) {\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler =\n        typeof observer === \"function\" ? observer : observer.next && observer.next.bind(observer);\n      if (!handler) {\n        return {\n          unsubscribe() {}\n        };\n      }\n      const dispose = createRoot(disposer => {\n        createEffect(() => {\n          const v = input();\n          untrack(() => handler(v));\n        });\n        return disposer;\n      });\n      if (getOwner()) onCleanup(dispose);\n      return {\n        unsubscribe() {\n          dispose();\n        }\n      };\n    },\n    [Symbol.observable || \"@@observable\"]() {\n      return this;\n    }\n  };\n}\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => (\"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub()));\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n    mapped = [],\n    disposers = [],\n    len = 0,\n    indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n      i,\n      j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newLen = newItems.length,\n        newIndices,\n        newIndicesNext,\n        temp,\n        tempdisposers,\n        tempIndexes,\n        start,\n        end,\n        newEnd,\n        item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      } else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (\n          start = 0, end = Math.min(len, newLen);\n          start < end && items[start] === newItems[start];\n          start++\n        );\n        for (\n          end = len - 1, newEnd = newLen - 1;\n          end >= start && newEnd >= start && items[end] === newItems[newEnd];\n          end--, newEnd--\n        ) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, (len = newLen));\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j, {\n          name: \"index\"\n        });\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n    mapped = [],\n    disposers = [],\n    signals = [],\n    len = 0,\n    i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    newItems[$TRACK];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return (mapped = mapped.slice(0, len));\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i], {\n        name: \"value\"\n      });\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nlet hydrationEnabled = false;\nfunction enableHydration() {\n  hydrationEnabled = true;\n}\nfunction createComponent(Comp, props) {\n  if (hydrationEnabled) {\n    if (sharedConfig.context) {\n      const c = sharedConfig.context;\n      setHydrateContext(nextHydrateContext());\n      const r = devComponent(Comp, props || {});\n      setHydrateContext(c);\n      return r;\n    }\n  }\n  return devComponent(Comp, props || {});\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    if (property === $PROXY) return true;\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return !(s = typeof s === \"function\" ? s() : s) ? {} : s;\n}\nfunction resolveSources() {\n  for (let i = 0, length = this.length; i < length; ++i) {\n    const v = this[i]();\n    if (v !== undefined) return v;\n  }\n}\nfunction mergeProps(...sources) {\n  let proxy = false;\n  for (let i = 0; i < sources.length; i++) {\n    const s = sources[i];\n    proxy = proxy || (!!s && $PROXY in s);\n    sources[i] = typeof s === \"function\" ? ((proxy = true), createMemo(s)) : s;\n  }\n  if (proxy) {\n    return new Proxy(\n      {\n        get(property) {\n          for (let i = sources.length - 1; i >= 0; i--) {\n            const v = resolveSource(sources[i])[property];\n            if (v !== undefined) return v;\n          }\n        },\n        has(property) {\n          for (let i = sources.length - 1; i >= 0; i--) {\n            if (property in resolveSource(sources[i])) return true;\n          }\n          return false;\n        },\n        keys() {\n          const keys = [];\n          for (let i = 0; i < sources.length; i++)\n            keys.push(...Object.keys(resolveSource(sources[i])));\n          return [...new Set(keys)];\n        }\n      },\n      propTraps\n    );\n  }\n  const sourcesMap = {};\n  const defined = Object.create(null);\n  for (let i = sources.length - 1; i >= 0; i--) {\n    const source = sources[i];\n    if (!source) continue;\n    const sourceKeys = Object.getOwnPropertyNames(source);\n    for (let i = sourceKeys.length - 1; i >= 0; i--) {\n      const key = sourceKeys[i];\n      if (key === \"__proto__\" || key === \"constructor\") continue;\n      const desc = Object.getOwnPropertyDescriptor(source, key);\n      if (!defined[key]) {\n        defined[key] = desc.get\n          ? {\n              enumerable: true,\n              configurable: true,\n              get: resolveSources.bind((sourcesMap[key] = [desc.get.bind(source)]))\n            }\n          : desc.value !== undefined\n          ? desc\n          : undefined;\n      } else {\n        const sources = sourcesMap[key];\n        if (sources) {\n          if (desc.get) sources.push(desc.get.bind(source));\n          else if (desc.value !== undefined) sources.push(() => desc.value);\n        }\n      }\n    }\n  }\n  const target = {};\n  const definedKeys = Object.keys(defined);\n  for (let i = definedKeys.length - 1; i >= 0; i--) {\n    const key = definedKeys[i],\n      desc = defined[key];\n    if (desc && desc.get) Object.defineProperty(target, key, desc);\n    else target[key] = desc ? desc.value : undefined;\n  }\n  return target;\n}\nfunction splitProps(props, ...keys) {\n  if ($PROXY in props) {\n    const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);\n    const res = keys.map(k => {\n      return new Proxy(\n        {\n          get(property) {\n            return k.includes(property) ? props[property] : undefined;\n          },\n          has(property) {\n            return k.includes(property) && property in props;\n          },\n          keys() {\n            return k.filter(property => property in props);\n          }\n        },\n        propTraps\n      );\n    });\n    res.push(\n      new Proxy(\n        {\n          get(property) {\n            return blocked.has(property) ? undefined : props[property];\n          },\n          has(property) {\n            return blocked.has(property) ? false : property in props;\n          },\n          keys() {\n            return Object.keys(props).filter(k => !blocked.has(k));\n          }\n        },\n        propTraps\n      )\n    );\n    return res;\n  }\n  const otherObject = {};\n  const objects = keys.map(() => ({}));\n  for (const propName of Object.getOwnPropertyNames(props)) {\n    const desc = Object.getOwnPropertyDescriptor(props, propName);\n    const isDefaultDesc =\n      !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;\n    let blocked = false;\n    let objectIndex = 0;\n    for (const k of keys) {\n      if (k.includes(propName)) {\n        blocked = true;\n        isDefaultDesc\n          ? (objects[objectIndex][propName] = desc.value)\n          : Object.defineProperty(objects[objectIndex], propName, desc);\n      }\n      ++objectIndex;\n    }\n    if (!blocked) {\n      isDefaultDesc\n        ? (otherObject[propName] = desc.value)\n        : Object.defineProperty(otherObject, propName, desc);\n    }\n  }\n  return [...objects, otherObject];\n}\nfunction lazy(fn) {\n  let comp;\n  let p;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx) {\n      const [s, set] = createSignal();\n      sharedConfig.count || (sharedConfig.count = 0);\n      sharedConfig.count++;\n      (p || (p = fn())).then(mod => {\n        setHydrateContext(ctx);\n        sharedConfig.count--;\n        set(() => mod.default);\n        setHydrateContext();\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => (p || (p = fn())).then(mod => mod.default));\n      comp = s;\n    }\n    let Comp;\n    return createMemo(\n      () =>\n        (Comp = comp()) &&\n        untrack(() => {\n          if (true)\n            Object.assign(Comp, {\n              [$DEVCOMP]: true\n            });\n          if (!ctx) return Comp(props);\n          const c = sharedConfig.context;\n          setHydrateContext(ctx);\n          const r = Comp(props);\n          setHydrateContext(c);\n          return r;\n        })\n    );\n  };\n  wrap.preload = () => p || ((p = fn()).then(mod => (comp = () => mod.default)), p);\n  return wrap;\n}\nlet counter = 0;\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? `${ctx.id}${ctx.count++}` : `cl-${counter++}`;\n}\n\nconst narrowedError = name =>\n  `Attempting to access a stale value from <${name}> that could possibly be undefined. This may occur because you are reading the accessor returned from the component at a time where it has already been unmounted. We recommend cleaning up any stale timers or async, or reading from the initial condition.`;\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(\n    mapArray(() => props.each, props.children, fallback || undefined),\n    undefined,\n    {\n      name: \"value\"\n    }\n  );\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(\n    indexArray(() => props.each, props.children, fallback || undefined),\n    undefined,\n    {\n      name: \"value\"\n    }\n  );\n}\nfunction Show(props) {\n  const keyed = props.keyed;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => (keyed ? a === b : !a === !b),\n    name: \"condition\"\n  });\n  return createMemo(\n    () => {\n      const c = condition();\n      if (c) {\n        const child = props.children;\n        const fn = typeof child === \"function\" && child.length > 0;\n        return fn\n          ? untrack(() =>\n              child(\n                keyed\n                  ? c\n                  : () => {\n                      if (!untrack(condition)) throw narrowedError(\"Show\");\n                      return props.when;\n                    }\n              )\n            )\n          : child;\n      }\n      return props.fallback;\n    },\n    undefined,\n    {\n      name: \"value\"\n    }\n  );\n}\nfunction Switch(props) {\n  let keyed = false;\n  const equals = (a, b) => (keyed ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2];\n  const conditions = children(() => props.children),\n    evalConditions = createMemo(\n      () => {\n        let conds = conditions();\n        if (!Array.isArray(conds)) conds = [conds];\n        for (let i = 0; i < conds.length; i++) {\n          const c = conds[i].when;\n          if (c) {\n            keyed = !!conds[i].keyed;\n            return [i, c, conds[i]];\n          }\n        }\n        return [-1];\n      },\n      undefined,\n      {\n        equals,\n        name: \"eval conditions\"\n      }\n    );\n  return createMemo(\n    () => {\n      const [index, when, cond] = evalConditions();\n      if (index < 0) return props.fallback;\n      const c = cond.children;\n      const fn = typeof c === \"function\" && c.length > 0;\n      return fn\n        ? untrack(() =>\n            c(\n              keyed\n                ? when\n                : () => {\n                    if (untrack(evalConditions)[0] !== index) throw narrowedError(\"Match\");\n                    return cond.when;\n                  }\n            )\n          )\n        : c;\n    },\n    undefined,\n    {\n      name: \"value\"\n    }\n  );\n}\nfunction Match(props) {\n  return props;\n}\nlet Errors;\nfunction resetErrorBoundaries() {\n  Errors && [...Errors].forEach(fn => fn());\n}\nfunction ErrorBoundary(props) {\n  let err;\n  if (sharedConfig.context && sharedConfig.load)\n    err = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count);\n  const [errored, setErrored] = createSignal(err, {\n    name: \"errored\"\n  });\n  Errors || (Errors = new Set());\n  Errors.add(setErrored);\n  onCleanup(() => Errors.delete(setErrored));\n  return createMemo(\n    () => {\n      let e;\n      if ((e = errored())) {\n        const f = props.fallback;\n        if (typeof f !== \"function\" || f.length == 0) console.error(e);\n        return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored())) : f;\n      }\n      return catchError(() => props.children, setErrored);\n    },\n    undefined,\n    {\n      name: \"value\"\n    }\n  );\n}\n\nconst suspenseListEquals = (a, b) =>\n  a.showContent === b.showContent && a.showFallback === b.showFallback;\nconst SuspenseListContext = createContext();\nfunction SuspenseList(props) {\n  let [wrapper, setWrapper] = createSignal(() => ({\n      inFallback: false\n    })),\n    show;\n  const listContext = useContext(SuspenseListContext);\n  const [registry, setRegistry] = createSignal([]);\n  if (listContext) {\n    show = listContext.register(createMemo(() => wrapper()().inFallback));\n  }\n  const resolved = createMemo(\n    prev => {\n      const reveal = props.revealOrder,\n        tail = props.tail,\n        { showContent = true, showFallback = true } = show ? show() : {},\n        reg = registry(),\n        reverse = reveal === \"backwards\";\n      if (reveal === \"together\") {\n        const all = reg.every(inFallback => !inFallback());\n        const res = reg.map(() => ({\n          showContent: all && showContent,\n          showFallback\n        }));\n        res.inFallback = !all;\n        return res;\n      }\n      let stop = false;\n      let inFallback = prev.inFallback;\n      const res = [];\n      for (let i = 0, len = reg.length; i < len; i++) {\n        const n = reverse ? len - i - 1 : i,\n          s = reg[n]();\n        if (!stop && !s) {\n          res[n] = {\n            showContent,\n            showFallback\n          };\n        } else {\n          const next = !stop;\n          if (next) inFallback = true;\n          res[n] = {\n            showContent: next,\n            showFallback: !tail || (next && tail === \"collapsed\") ? showFallback : false\n          };\n          stop = true;\n        }\n      }\n      if (!stop) inFallback = false;\n      res.inFallback = inFallback;\n      return res;\n    },\n    {\n      inFallback: false\n    }\n  );\n  setWrapper(() => resolved);\n  return createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        let index;\n        setRegistry(registry => {\n          index = registry.length;\n          return [...registry, inFallback];\n        });\n        return createMemo(() => resolved()[index], undefined, {\n          equals: suspenseListEquals\n        });\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n}\nfunction Suspense(props) {\n  let counter = 0,\n    show,\n    ctx,\n    p,\n    flicker,\n    error;\n  const [inFallback, setFallback] = createSignal(false),\n    SuspenseContext = getSuspenseContext(),\n    store = {\n      increment: () => {\n        if (++counter === 1) setFallback(true);\n      },\n      decrement: () => {\n        if (--counter === 0) setFallback(false);\n      },\n      inFallback,\n      effects: [],\n      resolved: false\n    },\n    owner = getOwner();\n  if (sharedConfig.context && sharedConfig.load) {\n    const key = sharedConfig.context.id + sharedConfig.context.count;\n    let ref = sharedConfig.load(key);\n    if (ref) {\n      if (typeof ref !== \"object\" || ref.status !== \"success\") p = ref;\n      else sharedConfig.gather(key);\n    }\n    if (p && p !== \"$$f\") {\n      const [s, set] = createSignal(undefined, {\n        equals: false\n      });\n      flicker = s;\n      p.then(\n        () => {\n          if (sharedConfig.done) return set();\n          sharedConfig.gather(key);\n          setHydrateContext(ctx);\n          set();\n          setHydrateContext();\n        },\n        err => {\n          error = err;\n          set();\n        }\n      );\n    }\n  }\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) show = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      return createMemo(() => {\n        if (error) throw error;\n        ctx = sharedConfig.context;\n        if (flicker) {\n          flicker();\n          return (flicker = undefined);\n        }\n        if (ctx && p === \"$$f\") setHydrateContext();\n        const rendered = createMemo(() => props.children);\n        return createMemo(prev => {\n          const inFallback = store.inFallback(),\n            { showContent = true, showFallback = true } = show ? show() : {};\n          if ((!inFallback || (p && p !== \"$$f\")) && showContent) {\n            store.resolved = true;\n            dispose && dispose();\n            dispose = ctx = p = undefined;\n            resumeEffects(store.effects);\n            return rendered();\n          }\n          if (!showFallback) return;\n          if (dispose) return prev;\n          return createRoot(disposer => {\n            dispose = disposer;\n            if (ctx) {\n              setHydrateContext({\n                id: ctx.id + \"f\",\n                count: 0\n              });\n              ctx = undefined;\n            }\n            return props.fallback;\n          }, owner);\n        });\n      });\n    }\n  });\n}\n\nconst DEV = {\n  hooks: DevHooks,\n  writeSignal,\n  registerGraph\n};\nif (globalThis) {\n  if (!globalThis.Solid$$) globalThis.Solid$$ = true;\n  else\n    console.warn(\n      \"You appear to have multiple instances of Solid. This can lead to unexpected behavior.\"\n    );\n}\n\n\n\n\n//# sourceURL=webpack://_muse/./node_modules/solid-js/dist/dev.js?");

/***/ }),

/***/ "./node_modules/solid-js/store/dist/dev.js":
/*!*************************************************!*\
  !*** ./node_modules/solid-js/store/dist/dev.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   produce: () => (/* binding */ produce)\n/* harmony export */ });\n/* unused harmony exports $RAW, DEV, createMutable, modifyMutable, reconcile, unwrap */\n/* harmony import */ var solid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! solid-js */ \"./node_modules/solid-js/dist/dev.js\");\n\n\nconst $RAW = Symbol(\"store-raw\"),\n  $NODE = Symbol(\"store-node\"),\n  $HAS = Symbol(\"store-has\"),\n  $SELF = Symbol(\"store-self\");\nconst DevHooks = {\n  onStoreNodeUpdate: null\n};\nfunction wrap$1(value) {\n  let p = value[solid_js__WEBPACK_IMPORTED_MODULE_0__.$PROXY];\n  if (!p) {\n    Object.defineProperty(value, solid_js__WEBPACK_IMPORTED_MODULE_0__.$PROXY, {\n      value: (p = new Proxy(value, proxyTraps$1))\n    });\n    if (!Array.isArray(value)) {\n      const keys = Object.keys(value),\n        desc = Object.getOwnPropertyDescriptors(value);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const prop = keys[i];\n        if (desc[prop].get) {\n          Object.defineProperty(value, prop, {\n            enumerable: desc[prop].enumerable,\n            get: desc[prop].get.bind(p)\n          });\n        }\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return (\n    obj != null &&\n    typeof obj === \"object\" &&\n    (obj[solid_js__WEBPACK_IMPORTED_MODULE_0__.$PROXY] ||\n      !(proto = Object.getPrototypeOf(obj)) ||\n      proto === Object.prototype ||\n      Array.isArray(obj))\n  );\n}\nfunction unwrap(item, set = new Set()) {\n  let result, unwrapped, v, prop;\n  if ((result = item != null && item[$RAW])) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);\n    else set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);\n    else set.add(item);\n    const keys = Object.keys(item),\n      desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getNodes(target, symbol) {\n  let nodes = target[symbol];\n  if (!nodes)\n    Object.defineProperty(target, symbol, {\n      value: (nodes = Object.create(null))\n    });\n  return nodes;\n}\nfunction getNode(nodes, property, value) {\n  if (nodes[property]) return nodes[property];\n  const [s, set] = (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.createSignal)(value, {\n    equals: false,\n    internal: true\n  });\n  s.$ = set;\n  return (nodes[property] = s);\n}\nfunction proxyDescriptor$1(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === solid_js__WEBPACK_IMPORTED_MODULE_0__.$PROXY || property === $NODE)\n    return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[solid_js__WEBPACK_IMPORTED_MODULE_0__.$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.getListener)() && getNode(getNodes(target, $NODE), $SELF)();\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === solid_js__WEBPACK_IMPORTED_MODULE_0__.$PROXY) return receiver;\n    if (property === solid_js__WEBPACK_IMPORTED_MODULE_0__.$TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (\n        (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.getListener)() &&\n        (typeof value !== \"function\" || target.hasOwnProperty(property)) &&\n        !(desc && desc.get)\n      )\n        value = getNode(nodes, property, value)();\n    }\n    return isWrappable(value) ? wrap$1(value) : value;\n  },\n  has(target, property) {\n    if (\n      property === $RAW ||\n      property === solid_js__WEBPACK_IMPORTED_MODULE_0__.$PROXY ||\n      property === solid_js__WEBPACK_IMPORTED_MODULE_0__.$TRACK ||\n      property === $NODE ||\n      property === $HAS ||\n      property === \"__proto__\"\n    )\n      return true;\n    (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.getListener)() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set() {\n    console.warn(\"Cannot mutate a Store directly\");\n    return true;\n  },\n  deleteProperty() {\n    console.warn(\"Cannot mutate a Store directly\");\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor$1\n};\nfunction setProperty(state, property, value, deleting = false) {\n  if (!deleting && state[property] === value) return;\n  const prev = state[property],\n    len = state.length;\n  DevHooks.onStoreNodeUpdate && DevHooks.onStoreNodeUpdate(state, property, value, prev);\n  if (value === undefined) {\n    delete state[property];\n    if (state[$HAS] && state[$HAS][property] && prev !== undefined) state[$HAS][property].$();\n  } else {\n    state[property] = value;\n    if (state[$HAS] && state[$HAS][property] && prev === undefined) state[$HAS][property].$();\n  }\n  let nodes = getNodes(state, $NODE),\n    node;\n  if ((node = getNode(nodes, property, prev))) node.$(() => value);\n  if (Array.isArray(state) && state.length !== len) {\n    for (let i = state.length; i < len; i++) (node = nodes[i]) && node.$();\n    (node = getNode(nodes, \"length\", len)) && node.$(state.length);\n  }\n  (node = nodes[$SELF]) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updateArray(current, next) {\n  if (typeof next === \"function\") next = next(current);\n  next = unwrap(next);\n  if (Array.isArray(next)) {\n    if (current === next) return;\n    let i = 0,\n      len = next.length;\n    for (; i < len; i++) {\n      const value = next[i];\n      if (current[i] !== value) setProperty(current, i, value);\n    }\n    setProperty(current, \"length\", len);\n  } else mergeStoreNode(current, next);\n}\nfunction updatePath(current, path, traversed = []) {\n  let part,\n    prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part,\n      isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i = 0; i < part.length; i++) {\n        updatePath(current, [part[i]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i = 0; i < current.length; i++) {\n        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const { from = 0, to = current.length - 1, by = 1 } = part;\n      for (let i = from; i <= to; i += by) {\n        updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === undefined && value == undefined) return;\n  value = unwrap(value);\n  if (part === undefined || (isWrappable(prev) && isWrappable(value) && !Array.isArray(value))) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(...[store, options]) {\n  const unwrappedStore = unwrap(store || {});\n  const isArray = Array.isArray(unwrappedStore);\n  if (typeof unwrappedStore !== \"object\" && typeof unwrappedStore !== \"function\")\n    throw new Error(\n      `Unexpected type ${typeof unwrappedStore} received when initializing 'createStore'. Expected an object.`\n    );\n  const wrappedStore = wrap$1(unwrappedStore);\n  solid_js__WEBPACK_IMPORTED_MODULE_0__.DEV.registerGraph({\n    value: unwrappedStore,\n    name: options && options.name\n  });\n  function setStore(...args) {\n    (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.batch)(() => {\n      isArray && args.length === 1\n        ? updateArray(unwrappedStore, args[0])\n        : updatePath(unwrappedStore, args);\n    });\n  }\n  return [wrappedStore, setStore];\n}\n\nfunction proxyDescriptor(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (\n    !desc ||\n    desc.get ||\n    desc.set ||\n    !desc.configurable ||\n    property === solid_js__WEBPACK_IMPORTED_MODULE_0__.$PROXY ||\n    property === $NODE\n  )\n    return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[solid_js__WEBPACK_IMPORTED_MODULE_0__.$PROXY][property];\n  desc.set = v => (target[solid_js__WEBPACK_IMPORTED_MODULE_0__.$PROXY][property] = v);\n  return desc;\n}\nconst proxyTraps = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === solid_js__WEBPACK_IMPORTED_MODULE_0__.$PROXY) return receiver;\n    if (property === solid_js__WEBPACK_IMPORTED_MODULE_0__.$TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      const isFunction = typeof value === \"function\";\n      if ((0,solid_js__WEBPACK_IMPORTED_MODULE_0__.getListener)() && (!isFunction || target.hasOwnProperty(property)) && !(desc && desc.get))\n        value = getNode(nodes, property, value)();\n      else if (value != null && isFunction && value === Array.prototype[property]) {\n        return (...args) => (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.batch)(() => Array.prototype[property].apply(receiver, args));\n      }\n    }\n    return isWrappable(value) ? wrap(value) : value;\n  },\n  has(target, property) {\n    if (\n      property === $RAW ||\n      property === solid_js__WEBPACK_IMPORTED_MODULE_0__.$PROXY ||\n      property === solid_js__WEBPACK_IMPORTED_MODULE_0__.$TRACK ||\n      property === $NODE ||\n      property === $HAS ||\n      property === \"__proto__\"\n    )\n      return true;\n    (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.getListener)() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set(target, property, value) {\n    (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.batch)(() => setProperty(target, property, unwrap(value)));\n    return true;\n  },\n  deleteProperty(target, property) {\n    (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.batch)(() => setProperty(target, property, undefined, true));\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction wrap(value) {\n  let p = value[solid_js__WEBPACK_IMPORTED_MODULE_0__.$PROXY];\n  if (!p) {\n    Object.defineProperty(value, solid_js__WEBPACK_IMPORTED_MODULE_0__.$PROXY, {\n      value: (p = new Proxy(value, proxyTraps))\n    });\n    const keys = Object.keys(value),\n      desc = Object.getOwnPropertyDescriptors(value);\n    const proto = Object.getPrototypeOf(value);\n    const isClass =\n      value !== null &&\n      typeof value === \"object\" &&\n      !Array.isArray(value) &&\n      proto !== Object.prototype;\n    if (isClass) {\n      const descriptors = Object.getOwnPropertyDescriptors(proto);\n      keys.push(...Object.keys(descriptors));\n      Object.assign(desc, descriptors);\n    }\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (isClass && prop === \"constructor\") continue;\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get,\n          configurable: true\n        });\n      }\n      if (desc[prop].set) {\n        const og = desc[prop].set,\n          set = v => (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.batch)(() => og.call(p, v));\n        Object.defineProperty(value, prop, {\n          set,\n          configurable: true\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction createMutable(state, options) {\n  const unwrappedStore = unwrap(state || {});\n  if (typeof unwrappedStore !== \"object\" && typeof unwrappedStore !== \"function\")\n    throw new Error(\n      `Unexpected type ${typeof unwrappedStore} received when initializing 'createMutable'. Expected an object.`\n    );\n  const wrappedStore = wrap(unwrappedStore);\n  solid_js__WEBPACK_IMPORTED_MODULE_0__.DEV.registerGraph({\n    value: unwrappedStore,\n    name: options && options.name\n  });\n  return wrappedStore;\n}\nfunction modifyMutable(state, modifier) {\n  (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.batch)(() => modifier(unwrap(state)));\n}\n\nconst $ROOT = Symbol(\"store-root\");\nfunction applyState(target, parent, property, merge, key) {\n  const previous = parent[property];\n  if (target === previous) return;\n  const isArray = Array.isArray(target);\n  if (\n    property !== $ROOT &&\n    (!isWrappable(target) ||\n      !isWrappable(previous) ||\n      isArray !== Array.isArray(previous) ||\n      (key && target[key] !== previous[key]))\n  ) {\n    setProperty(parent, property, target);\n    return;\n  }\n  if (isArray) {\n    if (\n      target.length &&\n      previous.length &&\n      (!merge || (key && target[0] && target[0][key] != null))\n    ) {\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\n      for (\n        start = 0, end = Math.min(previous.length, target.length);\n        start < end &&\n        (previous[start] === target[start] ||\n          (key && previous[start] && target[start] && previous[start][key] === target[start][key]));\n        start++\n      ) {\n        applyState(target[start], previous, start, merge, key);\n      }\n      const temp = new Array(target.length),\n        newIndices = new Map();\n      for (\n        end = previous.length - 1, newEnd = target.length - 1;\n        end >= start &&\n        newEnd >= start &&\n        (previous[end] === target[newEnd] ||\n          (key && previous[start] && target[start] && previous[end][key] === target[newEnd][key]));\n        end--, newEnd--\n      ) {\n        temp[newEnd] = previous[end];\n      }\n      if (start > newEnd || start > end) {\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\n        for (; j < target.length; j++) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        }\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n        return;\n      }\n      newIndicesNext = new Array(newEnd + 1);\n      for (j = newEnd; j >= start; j--) {\n        item = target[j];\n        keyVal = key && item ? item[key] : item;\n        i = newIndices.get(keyVal);\n        newIndicesNext[j] = i === undefined ? -1 : i;\n        newIndices.set(keyVal, j);\n      }\n      for (i = start; i <= end; i++) {\n        item = previous[i];\n        keyVal = key && item ? item[key] : item;\n        j = newIndices.get(keyVal);\n        if (j !== undefined && j !== -1) {\n          temp[j] = previous[i];\n          j = newIndicesNext[j];\n          newIndices.set(keyVal, j);\n        }\n      }\n      for (j = start; j < target.length; j++) {\n        if (j in temp) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        } else setProperty(previous, j, target[j]);\n      }\n    } else {\n      for (let i = 0, len = target.length; i < len; i++) {\n        applyState(target[i], previous, i, merge, key);\n      }\n    }\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n    return;\n  }\n  const targetKeys = Object.keys(target);\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\n  }\n  const previousKeys = Object.keys(previous);\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\n  }\n}\nfunction reconcile(value, options = {}) {\n  const { merge, key = \"id\" } = options,\n    v = unwrap(value);\n  return state => {\n    if (!isWrappable(state) || !isWrappable(v)) return v;\n    const res = applyState(\n      v,\n      {\n        [$ROOT]: state\n      },\n      $ROOT,\n      merge,\n      key\n    );\n    return res === undefined ? state : res;\n  };\n}\nconst producers = new WeakMap();\nconst setterTraps = {\n  get(target, property) {\n    if (property === $RAW) return target;\n    const value = target[property];\n    let proxy;\n    return isWrappable(value)\n      ? producers.get(value) ||\n          (producers.set(value, (proxy = new Proxy(value, setterTraps))), proxy)\n      : value;\n  },\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined, true);\n    return true;\n  }\n};\nfunction produce(fn) {\n  return state => {\n    if (isWrappable(state)) {\n      let proxy;\n      if (!(proxy = producers.get(state))) {\n        producers.set(state, (proxy = new Proxy(state, setterTraps)));\n      }\n      fn(proxy);\n    }\n    return state;\n  };\n}\n\nconst DEV = {\n  $NODE,\n  isWrappable,\n  hooks: DevHooks\n};\n\n\n\n\n//# sourceURL=webpack://_muse/./node_modules/solid-js/store/dist/dev.js?");

/***/ }),

/***/ "./node_modules/solid-js/web/dist/dev.js":
/*!***********************************************!*\
  !*** ./node_modules/solid-js/web/dist/dev.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   className: () => (/* binding */ className),\n/* harmony export */   insert: () => (/* binding */ insert),\n/* harmony export */   setAttribute: () => (/* binding */ setAttribute),\n/* harmony export */   spread: () => (/* binding */ spread),\n/* harmony export */   style: () => (/* binding */ style),\n/* harmony export */   template: () => (/* binding */ template)\n/* harmony export */ });\n/* unused harmony exports Aliases, Assets, ChildProperties, DOMElements, DelegatedEvents, Dynamic, Hydration, HydrationScript, NoHydration, Portal, Properties, RequestContext, SVGElements, SVGNamespace, addEventListener, assign, classList, clearDelegatedEvents, delegateEvents, dynamicProperty, escape, generateHydrationScript, getAssets, getHydrationKey, getNextElement, getNextMarker, getNextMatch, getPropAlias, getRequestEvent, hydrate, innerHTML, isDev, isServer, render, renderToStream, renderToString, renderToStringAsync, resolveSSRNode, runHydrationEvents, setAttributeNS, setProperty, ssr, ssrAttribute, ssrClassList, ssrElement, ssrHydrationKey, ssrSpread, ssrStyle, use, useAssets */\n/* harmony import */ var solid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! solid-js */ \"./node_modules/solid-js/dist/dev.js\");\n\n\n\nconst booleans = [\n  \"allowfullscreen\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"indeterminate\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"seamless\",\n  \"selected\"\n];\nconst Properties = /*#__PURE__*/ new Set([\n  \"className\",\n  \"value\",\n  \"readOnly\",\n  \"formNoValidate\",\n  \"isMap\",\n  \"noModule\",\n  \"playsInline\",\n  ...booleans\n]);\nconst ChildProperties = /*#__PURE__*/ new Set([\n  \"innerHTML\",\n  \"textContent\",\n  \"innerText\",\n  \"children\"\n]);\nconst Aliases = /*#__PURE__*/ Object.assign(Object.create(null), {\n  className: \"class\",\n  htmlFor: \"for\"\n});\nconst PropAliases = /*#__PURE__*/ Object.assign(Object.create(null), {\n  class: \"className\",\n  formnovalidate: {\n    $: \"formNoValidate\",\n    BUTTON: 1,\n    INPUT: 1\n  },\n  ismap: {\n    $: \"isMap\",\n    IMG: 1\n  },\n  nomodule: {\n    $: \"noModule\",\n    SCRIPT: 1\n  },\n  playsinline: {\n    $: \"playsInline\",\n    VIDEO: 1\n  },\n  readonly: {\n    $: \"readOnly\",\n    INPUT: 1,\n    TEXTAREA: 1\n  }\n});\nfunction getPropAlias(prop, tagName) {\n  const a = PropAliases[prop];\n  return typeof a === \"object\" ? (a[tagName] ? a[\"$\"] : undefined) : a;\n}\nconst DelegatedEvents = /*#__PURE__*/ new Set([\n  \"beforeinput\",\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"focusin\",\n  \"focusout\",\n  \"input\",\n  \"keydown\",\n  \"keyup\",\n  \"mousedown\",\n  \"mousemove\",\n  \"mouseout\",\n  \"mouseover\",\n  \"mouseup\",\n  \"pointerdown\",\n  \"pointermove\",\n  \"pointerout\",\n  \"pointerover\",\n  \"pointerup\",\n  \"touchend\",\n  \"touchmove\",\n  \"touchstart\"\n]);\nconst SVGElements = /*#__PURE__*/ new Set([\n  \"altGlyph\",\n  \"altGlyphDef\",\n  \"altGlyphItem\",\n  \"animate\",\n  \"animateColor\",\n  \"animateMotion\",\n  \"animateTransform\",\n  \"circle\",\n  \"clipPath\",\n  \"color-profile\",\n  \"cursor\",\n  \"defs\",\n  \"desc\",\n  \"ellipse\",\n  \"feBlend\",\n  \"feColorMatrix\",\n  \"feComponentTransfer\",\n  \"feComposite\",\n  \"feConvolveMatrix\",\n  \"feDiffuseLighting\",\n  \"feDisplacementMap\",\n  \"feDistantLight\",\n  \"feDropShadow\",\n  \"feFlood\",\n  \"feFuncA\",\n  \"feFuncB\",\n  \"feFuncG\",\n  \"feFuncR\",\n  \"feGaussianBlur\",\n  \"feImage\",\n  \"feMerge\",\n  \"feMergeNode\",\n  \"feMorphology\",\n  \"feOffset\",\n  \"fePointLight\",\n  \"feSpecularLighting\",\n  \"feSpotLight\",\n  \"feTile\",\n  \"feTurbulence\",\n  \"filter\",\n  \"font\",\n  \"font-face\",\n  \"font-face-format\",\n  \"font-face-name\",\n  \"font-face-src\",\n  \"font-face-uri\",\n  \"foreignObject\",\n  \"g\",\n  \"glyph\",\n  \"glyphRef\",\n  \"hkern\",\n  \"image\",\n  \"line\",\n  \"linearGradient\",\n  \"marker\",\n  \"mask\",\n  \"metadata\",\n  \"missing-glyph\",\n  \"mpath\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"radialGradient\",\n  \"rect\",\n  \"set\",\n  \"stop\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"textPath\",\n  \"tref\",\n  \"tspan\",\n  \"use\",\n  \"view\",\n  \"vkern\"\n]);\nconst SVGNamespace = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\nconst DOMElements = /*#__PURE__*/ new Set([\n  \"html\",\n  \"base\",\n  \"head\",\n  \"link\",\n  \"meta\",\n  \"style\",\n  \"title\",\n  \"body\",\n  \"address\",\n  \"article\",\n  \"aside\",\n  \"footer\",\n  \"header\",\n  \"main\",\n  \"nav\",\n  \"section\",\n  \"body\",\n  \"blockquote\",\n  \"dd\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"figcaption\",\n  \"figure\",\n  \"hr\",\n  \"li\",\n  \"ol\",\n  \"p\",\n  \"pre\",\n  \"ul\",\n  \"a\",\n  \"abbr\",\n  \"b\",\n  \"bdi\",\n  \"bdo\",\n  \"br\",\n  \"cite\",\n  \"code\",\n  \"data\",\n  \"dfn\",\n  \"em\",\n  \"i\",\n  \"kbd\",\n  \"mark\",\n  \"q\",\n  \"rp\",\n  \"rt\",\n  \"ruby\",\n  \"s\",\n  \"samp\",\n  \"small\",\n  \"span\",\n  \"strong\",\n  \"sub\",\n  \"sup\",\n  \"time\",\n  \"u\",\n  \"var\",\n  \"wbr\",\n  \"area\",\n  \"audio\",\n  \"img\",\n  \"map\",\n  \"track\",\n  \"video\",\n  \"embed\",\n  \"iframe\",\n  \"object\",\n  \"param\",\n  \"picture\",\n  \"portal\",\n  \"source\",\n  \"svg\",\n  \"math\",\n  \"canvas\",\n  \"noscript\",\n  \"script\",\n  \"del\",\n  \"ins\",\n  \"caption\",\n  \"col\",\n  \"colgroup\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"tr\",\n  \"button\",\n  \"datalist\",\n  \"fieldset\",\n  \"form\",\n  \"input\",\n  \"label\",\n  \"legend\",\n  \"meter\",\n  \"optgroup\",\n  \"option\",\n  \"output\",\n  \"progress\",\n  \"select\",\n  \"textarea\",\n  \"details\",\n  \"dialog\",\n  \"menu\",\n  \"summary\",\n  \"details\",\n  \"slot\",\n  \"template\",\n  \"acronym\",\n  \"applet\",\n  \"basefont\",\n  \"bgsound\",\n  \"big\",\n  \"blink\",\n  \"center\",\n  \"content\",\n  \"dir\",\n  \"font\",\n  \"frame\",\n  \"frameset\",\n  \"hgroup\",\n  \"image\",\n  \"keygen\",\n  \"marquee\",\n  \"menuitem\",\n  \"nobr\",\n  \"noembed\",\n  \"noframes\",\n  \"plaintext\",\n  \"rb\",\n  \"rtc\",\n  \"shadow\",\n  \"spacer\",\n  \"strike\",\n  \"tt\",\n  \"xmp\",\n  \"a\",\n  \"abbr\",\n  \"acronym\",\n  \"address\",\n  \"applet\",\n  \"area\",\n  \"article\",\n  \"aside\",\n  \"audio\",\n  \"b\",\n  \"base\",\n  \"basefont\",\n  \"bdi\",\n  \"bdo\",\n  \"bgsound\",\n  \"big\",\n  \"blink\",\n  \"blockquote\",\n  \"body\",\n  \"br\",\n  \"button\",\n  \"canvas\",\n  \"caption\",\n  \"center\",\n  \"cite\",\n  \"code\",\n  \"col\",\n  \"colgroup\",\n  \"content\",\n  \"data\",\n  \"datalist\",\n  \"dd\",\n  \"del\",\n  \"details\",\n  \"dfn\",\n  \"dialog\",\n  \"dir\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"em\",\n  \"embed\",\n  \"fieldset\",\n  \"figcaption\",\n  \"figure\",\n  \"font\",\n  \"footer\",\n  \"form\",\n  \"frame\",\n  \"frameset\",\n  \"head\",\n  \"header\",\n  \"hgroup\",\n  \"hr\",\n  \"html\",\n  \"i\",\n  \"iframe\",\n  \"image\",\n  \"img\",\n  \"input\",\n  \"ins\",\n  \"kbd\",\n  \"keygen\",\n  \"label\",\n  \"legend\",\n  \"li\",\n  \"link\",\n  \"main\",\n  \"map\",\n  \"mark\",\n  \"marquee\",\n  \"menu\",\n  \"menuitem\",\n  \"meta\",\n  \"meter\",\n  \"nav\",\n  \"nobr\",\n  \"noembed\",\n  \"noframes\",\n  \"noscript\",\n  \"object\",\n  \"ol\",\n  \"optgroup\",\n  \"option\",\n  \"output\",\n  \"p\",\n  \"param\",\n  \"picture\",\n  \"plaintext\",\n  \"portal\",\n  \"pre\",\n  \"progress\",\n  \"q\",\n  \"rb\",\n  \"rp\",\n  \"rt\",\n  \"rtc\",\n  \"ruby\",\n  \"s\",\n  \"samp\",\n  \"script\",\n  \"section\",\n  \"select\",\n  \"shadow\",\n  \"slot\",\n  \"small\",\n  \"source\",\n  \"spacer\",\n  \"span\",\n  \"strike\",\n  \"strong\",\n  \"style\",\n  \"sub\",\n  \"summary\",\n  \"sup\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"template\",\n  \"textarea\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"time\",\n  \"title\",\n  \"tr\",\n  \"track\",\n  \"tt\",\n  \"u\",\n  \"ul\",\n  \"var\",\n  \"video\",\n  \"wbr\",\n  \"xmp\",\n  \"input\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\"\n]);\n\nfunction reconcileArrays(parentNode, a, b) {\n  let bLength = b.length,\n    aEnd = a.length,\n    bEnd = bLength,\n    aStart = 0,\n    bStart = 0,\n    after = a[aEnd - 1].nextSibling,\n    map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? (bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart]) : after;\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a[aStart])) a[aStart].remove();\n        aStart++;\n      }\n    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      const node = a[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      const index = map.get(a[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i = aStart,\n            sequence = 1,\n            t;\n          while (++i < aEnd && i < bEnd) {\n            if ((t = map.get(a[i])) == null || t !== index + sequence) break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a[aStart];\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a[aStart++]);\n        } else aStart++;\n      } else a[aStart++].remove();\n    }\n  }\n}\n\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init, options = {}) {\n  if (!element) {\n    throw new Error(\n      \"The `element` passed to `render(..., element)` doesn't exist. Make sure `element` exists in the document.\"\n    );\n  }\n  let disposer;\n  (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.createRoot)(dispose => {\n    disposer = dispose;\n    element === document\n      ? code()\n      : insert(element, code(), element.firstChild ? null : undefined, init);\n  }, options.owner);\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template(html, isCE, isSVG) {\n  let node;\n  const create = () => {\n    if (solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.context)\n      throw new Error(\n        \"Failed attempt to create new DOM elements during hydration. Check that the libraries you are using support hydration.\"\n      );\n    const t = document.createElement(\"template\");\n    t.innerHTML = html;\n    return isSVG ? t.content.firstChild.firstChild : t.content.firstChild;\n  };\n  const fn = isCE\n    ? () => (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.untrack)(() => document.importNode(node || (node = create()), true))\n    : () => (node || (node = create())).cloneNode(true);\n  fn.cloneNode = fn;\n  return fn;\n}\nfunction delegateEvents(eventNames, document = window.document) {\n  const e = document[$$EVENTS] || (document[$$EVENTS] = new Set());\n  for (let i = 0, l = eventNames.length; i < l; i++) {\n    const name = eventNames[i];\n    if (!e.has(name)) {\n      e.add(name);\n      document.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction clearDelegatedEvents(document = window.document) {\n  if (document[$$EVENTS]) {\n    for (let name of document[$$EVENTS].keys()) document.removeEventListener(name, eventHandler);\n    delete document[$$EVENTS];\n  }\n}\nfunction setProperty(node, name, value) {\n  if (!!solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.context && node.isConnected) return;\n  node[name] = value;\n}\nfunction setAttribute(node, name, value) {\n  if (!!solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.context && node.isConnected) return;\n  if (value == null) node.removeAttribute(name);\n  else node.setAttribute(name, value);\n}\nfunction setAttributeNS(node, namespace, name, value) {\n  if (!!solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.context && node.isConnected) return;\n  if (value == null) node.removeAttributeNS(namespace, name);\n  else node.setAttributeNS(namespace, name, value);\n}\nfunction className(node, value) {\n  if (!!solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.context && node.isConnected) return;\n  if (value == null) node.removeAttribute(\"class\");\n  else node.className = value;\n}\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    const handlerFn = handler[0];\n    node.addEventListener(name, (handler[0] = e => handlerFn.call(node, handler[1], e)));\n  } else node.addEventListener(name, handler);\n}\nfunction classList(node, value, prev = {}) {\n  const classKeys = Object.keys(value || {}),\n    prevKeys = Object.keys(prev);\n  let i, len;\n  for (i = 0, len = prevKeys.length; i < len; i++) {\n    const key = prevKeys[i];\n    if (!key || key === \"undefined\" || value[key]) continue;\n    toggleClassKey(node, key, false);\n    delete prev[key];\n  }\n  for (i = 0, len = classKeys.length; i < len; i++) {\n    const key = classKeys[i],\n      classValue = !!value[key];\n    if (!key || key === \"undefined\" || prev[key] === classValue || !classValue) continue;\n    toggleClassKey(node, key, true);\n    prev[key] = classValue;\n  }\n  return prev;\n}\nfunction style(node, value, prev) {\n  if (!value) return prev ? setAttribute(node, \"style\") : value;\n  const nodeStyle = node.style;\n  if (typeof value === \"string\") return (nodeStyle.cssText = value);\n  typeof prev === \"string\" && (nodeStyle.cssText = prev = undefined);\n  prev || (prev = {});\n  value || (value = {});\n  let v, s;\n  for (s in prev) {\n    value[s] == null && nodeStyle.removeProperty(s);\n    delete prev[s];\n  }\n  for (s in value) {\n    v = value[s];\n    if (v !== prev[s]) {\n      nodeStyle.setProperty(s, v);\n      prev[s] = v;\n    }\n  }\n  return prev;\n}\nfunction spread(node, props = {}, isSVG, skipChildren) {\n  const prevProps = {};\n  if (!skipChildren) {\n    (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.createRenderEffect)(\n      () => (prevProps.children = insertExpression(node, props.children, prevProps.children))\n    );\n  }\n  (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.createRenderEffect)(() =>\n    typeof props.ref === \"function\" ? use(props.ref, node) : (props.ref = node)\n  );\n  (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.createRenderEffect)(() => assign(node, props, isSVG, true, prevProps, true));\n  return prevProps;\n}\nfunction dynamicProperty(props, key) {\n  const src = props[key];\n  Object.defineProperty(props, key, {\n    get() {\n      return src();\n    },\n    enumerable: true\n  });\n  return props;\n}\nfunction use(fn, element, arg) {\n  return (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.untrack)(() => fn(element, arg));\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== undefined && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.createRenderEffect)(current => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {\n  props || (props = {});\n  for (const prop in prevProps) {\n    if (!(prop in props)) {\n      if (prop === \"children\") continue;\n      prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef);\n    }\n  }\n  for (const prop in props) {\n    if (prop === \"children\") {\n      if (!skipChildren) insertExpression(node, props.children);\n      continue;\n    }\n    const value = props[prop];\n    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef);\n  }\n}\nfunction hydrate$1(code, element, options = {}) {\n  solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.completed = globalThis._$HY.completed;\n  solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.events = globalThis._$HY.events;\n  solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.load = id => globalThis._$HY.r[id];\n  solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.has = id => id in globalThis._$HY.r;\n  solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.gather = root => gatherHydratable(element, root);\n  solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.registry = new Map();\n  solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.context = {\n    id: options.renderId || \"\",\n    count: 0\n  };\n  gatherHydratable(element, options.renderId);\n  const dispose = render(code, element, [...element.childNodes], options);\n  solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.context = null;\n  return dispose;\n}\nfunction getNextElement(template) {\n  let node, key;\n  if (!solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.context || !(node = solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.registry.get((key = getHydrationKey())))) {\n    if (solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.context)\n      throw new Error(`Hydration Mismatch. Unable to find DOM nodes for hydration key: ${key}`);\n    return template();\n  }\n  if (solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.completed) solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.completed.add(node);\n  solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.registry.delete(key);\n  return node;\n}\nfunction getNextMatch(el, nodeName) {\n  while (el && el.localName !== nodeName) el = el.nextSibling;\n  return el;\n}\nfunction getNextMarker(start) {\n  let end = start,\n    count = 0,\n    current = [];\n  if (solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.context) {\n    while (end) {\n      if (end.nodeType === 8) {\n        const v = end.nodeValue;\n        if (v === \"$\") count++;\n        else if (v === \"/\") {\n          if (count === 0) return [end, current];\n          count--;\n        }\n      }\n      current.push(end);\n      end = end.nextSibling;\n    }\n  }\n  return [end, current];\n}\nfunction runHydrationEvents() {\n  if (solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.events && !solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.events.queued) {\n    queueMicrotask(() => {\n      const { completed, events } = solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig;\n      events.queued = false;\n      while (events.length) {\n        const [el, e] = events[0];\n        if (!completed.has(el)) return;\n        eventHandler(e);\n        events.shift();\n      }\n    });\n    solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.events.queued = true;\n  }\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction toggleClassKey(node, key, value) {\n  const classNames = key.trim().split(/\\s+/);\n  for (let i = 0, nameLen = classNames.length; i < nameLen; i++)\n    node.classList.toggle(classNames[i], value);\n}\nfunction assignProp(node, prop, value, prev, isSVG, skipRef) {\n  let isCE, isProp, isChildProp, propAlias, forceProp;\n  if (prop === \"style\") return style(node, value, prev);\n  if (prop === \"classList\") return classList(node, value, prev);\n  if (value === prev) return prev;\n  if (prop === \"ref\") {\n    if (!skipRef) value(node);\n  } else if (prop.slice(0, 3) === \"on:\") {\n    const e = prop.slice(3);\n    prev && node.removeEventListener(e, prev);\n    value && node.addEventListener(e, value);\n  } else if (prop.slice(0, 10) === \"oncapture:\") {\n    const e = prop.slice(10);\n    prev && node.removeEventListener(e, prev, true);\n    value && node.addEventListener(e, value, true);\n  } else if (prop.slice(0, 2) === \"on\") {\n    const name = prop.slice(2).toLowerCase();\n    const delegate = DelegatedEvents.has(name);\n    if (!delegate && prev) {\n      const h = Array.isArray(prev) ? prev[0] : prev;\n      node.removeEventListener(name, h);\n    }\n    if (delegate || value) {\n      addEventListener(node, name, value, delegate);\n      delegate && delegateEvents([name]);\n    }\n  } else if (prop.slice(0, 5) === \"attr:\") {\n    setAttribute(node, prop.slice(5), value);\n  } else if (\n    (forceProp = prop.slice(0, 5) === \"prop:\") ||\n    (isChildProp = ChildProperties.has(prop)) ||\n    (!isSVG &&\n      ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop)))) ||\n    (isCE = node.nodeName.includes(\"-\"))\n  ) {\n    if (forceProp) {\n      prop = prop.slice(5);\n      isProp = true;\n    } else if (!!solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.context && node.isConnected) return value;\n    if (prop === \"class\" || prop === \"className\") className(node, value);\n    else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;\n    else node[propAlias || prop] = value;\n  } else {\n    const ns = isSVG && prop.indexOf(\":\") > -1 && SVGNamespace[prop.split(\":\")[0]];\n    if (ns) setAttributeNS(node, ns, prop, value);\n    else setAttribute(node, Aliases[prop] || prop, value);\n  }\n  return value;\n}\nfunction eventHandler(e) {\n  const key = `$$${e.type}`;\n  let node = (e.composedPath && e.composedPath()[0]) || e.target;\n  if (e.target !== node) {\n    Object.defineProperty(e, \"target\", {\n      configurable: true,\n      value: node\n    });\n  }\n  Object.defineProperty(e, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node || document;\n    }\n  });\n  if (solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.registry && !solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.done) solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.done = _$HY.done = true;\n  while (node) {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== undefined ? handler.call(node, data, e) : handler.call(node, e);\n      if (e.cancelBubble) return;\n    }\n    node = node._$host || node.parentNode || node.host;\n  }\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  const hydrating = !!solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.context && parent.isConnected;\n  if (hydrating) {\n    !current && (current = [...parent.childNodes]);\n    let cleaned = [];\n    for (let i = 0; i < current.length; i++) {\n      const node = current[i];\n      if (node.nodeType === 8 && node.data.slice(0, 2) === \"!$\") node.remove();\n      else cleaned.push(node);\n    }\n    current = cleaned;\n  }\n  while (typeof current === \"function\") current = current();\n  if (value === current) return current;\n  const t = typeof value,\n    multi = marker !== undefined;\n  parent = (multi && current[0] && current[0].parentNode) || parent;\n  if (t === \"string\" || t === \"number\") {\n    if (hydrating) return current;\n    if (t === \"number\") {\n      value = value.toString();\n      if (value === current) return current;\n    }\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data !== value && (node.data = value);\n      } else node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t === \"boolean\") {\n    if (hydrating) return current;\n    current = cleanChildren(parent, current, marker);\n  } else if (t === \"function\") {\n    (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.createRenderEffect)(() => {\n      let v = value();\n      while (typeof v === \"function\") v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    const currentArray = current && Array.isArray(current);\n    if (normalizeIncomingArray(array, value, current, unwrapArray)) {\n      (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.createRenderEffect)(() => (current = insertExpression(parent, array, current, marker, true)));\n      return () => current;\n    }\n    if (hydrating) {\n      if (!array.length) return current;\n      if (marker === undefined) return [...parent.childNodes];\n      let node = array[0];\n      let nodes = [node];\n      while ((node = node.nextSibling) !== marker) nodes.push(node);\n      return (current = nodes);\n    }\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else if (currentArray) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n    current = array;\n  } else if (value.nodeType) {\n    if (hydrating && value.parentNode) return (current = multi ? [value] : value);\n    if (Array.isArray(current)) {\n      if (multi) return (current = cleanChildren(parent, current, marker, value));\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else console.warn(`Unrecognized value. Skipped inserting`, value);\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, current, unwrap) {\n  let dynamic = false;\n  for (let i = 0, len = array.length; i < len; i++) {\n    let item = array[i],\n      prev = current && current[normalized.length],\n      t;\n    if (item == null || item === true || item === false);\n    else if ((t = typeof item) === \"object\" && item.nodeType) {\n      normalized.push(item);\n    } else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;\n    } else if (t === \"function\") {\n      if (unwrap) {\n        while (typeof item === \"function\") item = item();\n        dynamic =\n          normalizeIncomingArray(\n            normalized,\n            Array.isArray(item) ? item : [item],\n            Array.isArray(prev) ? prev : [prev]\n          ) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else {\n      const value = String(item);\n      if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);\n      else normalized.push(document.createTextNode(value));\n    }\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker = null) {\n  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === undefined) return (parent.textContent = \"\");\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i = current.length - 1; i >= 0; i--) {\n      const el = current[i];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i)\n          isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);\n        else isParent && el.remove();\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n  return [node];\n}\nfunction gatherHydratable(element, root) {\n  const templates = element.querySelectorAll(`*[data-hk]`);\n  for (let i = 0; i < templates.length; i++) {\n    const node = templates[i];\n    const key = node.getAttribute(\"data-hk\");\n    if ((!root || key.startsWith(root)) && !solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.registry.has(key))\n      solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.registry.set(key, node);\n  }\n}\nfunction getHydrationKey() {\n  const hydrate = solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.context;\n  return `${hydrate.id}${hydrate.count++}`;\n}\nfunction NoHydration(props) {\n  return solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.context ? undefined : props.children;\n}\nfunction Hydration(props) {\n  return props.children;\n}\nconst voidFn = () => undefined;\nconst RequestContext = Symbol();\nfunction innerHTML(parent, content) {\n  !solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.context && (parent.innerHTML = content);\n}\n\nfunction throwInBrowser(func) {\n  const err = new Error(`${func.name} is not supported in the browser, returning undefined`);\n  console.error(err);\n}\nfunction renderToString(fn, options) {\n  throwInBrowser(renderToString);\n}\nfunction renderToStringAsync(fn, options) {\n  throwInBrowser(renderToStringAsync);\n}\nfunction renderToStream(fn, options) {\n  throwInBrowser(renderToStream);\n}\nfunction ssr(template, ...nodes) {}\nfunction ssrElement(name, props, children, needsId) {}\nfunction ssrClassList(value) {}\nfunction ssrStyle(value) {}\nfunction ssrAttribute(key, value) {}\nfunction ssrHydrationKey() {}\nfunction resolveSSRNode(node) {}\nfunction escape(html) {}\nfunction ssrSpread(props, isSVG, skipChildren) {}\n\nconst isServer = false;\nconst isDev = true;\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nfunction createElement(tagName, isSVG = false) {\n  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);\n}\nconst hydrate = (...args) => {\n  (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.enableHydration)();\n  return hydrate$1(...args);\n};\nfunction Portal(props) {\n  const { useShadow } = props,\n    marker = document.createTextNode(\"\"),\n    mount = () => props.mount || document.body,\n    owner = (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.getOwner)();\n  let content;\n  let hydrating = !!solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.context;\n  (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.createEffect)(\n    () => {\n      if (hydrating) (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.getOwner)().user = hydrating = false;\n      content || (content = (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.runWithOwner)(owner, () => (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.createMemo)(() => props.children)));\n      const el = mount();\n      if (el instanceof HTMLHeadElement) {\n        const [clean, setClean] = (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.createSignal)(false);\n        const cleanup = () => setClean(true);\n        (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.createRoot)(dispose => insert(el, () => (!clean() ? content() : dispose()), null));\n        (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.onCleanup)(cleanup);\n      } else {\n        const container = createElement(props.isSVG ? \"g\" : \"div\", props.isSVG),\n          renderRoot =\n            useShadow && container.attachShadow\n              ? container.attachShadow({\n                  mode: \"open\"\n                })\n              : container;\n        Object.defineProperty(container, \"_$host\", {\n          get() {\n            return marker.parentNode;\n          },\n          configurable: true\n        });\n        insert(renderRoot, content);\n        el.appendChild(container);\n        props.ref && props.ref(container);\n        (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.onCleanup)(() => el.removeChild(container));\n      }\n    },\n    undefined,\n    {\n      render: !hydrating\n    }\n  );\n  return marker;\n}\nfunction Dynamic(props) {\n  const [p, others] = (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.splitProps)(props, [\"component\"]);\n  const cached = (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.createMemo)(() => p.component);\n  return (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.createMemo)(() => {\n    const component = cached();\n    switch (typeof component) {\n      case \"function\":\n        Object.assign(component, {\n          [solid_js__WEBPACK_IMPORTED_MODULE_0__.$DEVCOMP]: true\n        });\n        return (0,solid_js__WEBPACK_IMPORTED_MODULE_0__.untrack)(() => component(others));\n      case \"string\":\n        const isSvg = SVGElements.has(component);\n        const el = solid_js__WEBPACK_IMPORTED_MODULE_0__.sharedConfig.context ? getNextElement() : createElement(component, isSvg);\n        spread(el, others, isSvg);\n        return el;\n    }\n  });\n}\n\n\n\n\n//# sourceURL=webpack://_muse/./node_modules/solid-js/web/dist/dev.js?");

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"fullName\":\"_muse\",\"version\":\"24.7.1\",\"description\":\"_muse, master userscript extended\"}');\n\n//# sourceURL=webpack://_muse/./package.json?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./source/master.ts");
/******/ _muse = __webpack_exports__;
/******/ 
